/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * Copyright (c) 1996, by Sun Microsystems, Inc.
 * All rights reserved.
 */

#ident	"@(#)bdiff.c	1.12	98/06/24 SMI"	/* SVr4.0 5.11	*/

#include	<fatal.h>
#include	<signal.h>
#include	<sys/types.h>
#include	<unistd.h>
#include	<stdio.h>
#include	<ctype.h>
#include	<string.h>
#include 	<stdlib.h>
#include	<wait.h>

#define	ONSIG	16

char	*Mesg[ONSIG] = {
	0,
	0,	/* Hangup */
	0,	/* Interrupt */
	0,	/* Quit */
	"Illegal instruction",
	"Trace/BPT trap",
	"IOT trap",
	"EMT trap",
	"Floating exception",
	"Killed",
	"Bus error",
	"Memory fault",
	"Bad system call",
	"Broken pipe",
	"Alarm clock"
};

/*
 *	This program segments two files into pieces of <= seglim lines
 *	(which is passed as a third argument or defaulted to some number)
 *	and then executes diff upon the pieces. The output of
 *	'diff' is then processed to make it look as if 'diff' had
 *	processed the files whole. The reason for all this is that seglim
 *	is a reasonable upper limit on the size of files that diff can
 *	process.
 *	NOTE -- by segmenting the files in this manner, it cannot be
 *	guaranteed that the 'diffing' of the segments will generate
 *	a minimal set of differences.
 *	This process is most definitely not equivalent to 'diffing'
 *	the files whole, assuming 'diff' could handle such large files.
 *
 *	'diff' is executed by a child process, generated by forking,
 *	and communicates with this program through pipes.
 */

char Error[128];

int seglim;	/* limit of size of file segment to be generated */

FILE *fdopen();
char diff[]  =  "/usr/bin/diff";
char tempskel[] = "/tmp/bdXXXXXX";	/* used to generate temp file names */
char tempfile[32];
char otmp[32], ntmp[32];
int	Fflags;
int	fatal_num = 1;			/* exit number for fatal exit */
off_t	linenum;
size_t obufsiz, nbufsiz, dbufsiz;
char *readline(char **, size_t *, FILE *);
void addgen(char **, size_t *, FILE *);
void delgen(char **, size_t *, FILE *);
void fixnum(char *);
void fatal(char *);
void setsig();
char *satoi();

char *prognam;

void
main(int argc, char *argv[])
{
	FILE *poldfile, *pnewfile, *maket();
	char *oline, *nline, *diffline;
	char *olp, *nlp, *dp;
	int otcnt, ntcnt;
	pid_t i;
	int pfd[2];
	FILE *poldtemp, *pnewtemp, *pipeinp;
	int status;

	prognam = argv[0];
	/*
	 * Set flags for 'fatal' so that it will clean up,
	 * produce a message, and terminate.
	 */
	Fflags = FTLMSG | FTLCLN | FTLEXIT;

	setsig();

	if (argc < 3 || argc > 5)
		fatal("arg count");

	if (strcmp(argv[1], "-") == 0 && strcmp(argv[2], "-") == 0)
		fatal("both files standard input");
	if (strcmp(argv[1], "-") == 0)
		poldfile = stdin;
	else
		if ((poldfile = fopen(argv[1], "r")) == NULL) {
			snprintf(Error, sizeof (Error),
				"Can not open '%s'", argv[1]);
			fatal(Error);
		}
	if (strcmp(argv[2], "-") == 0)
		pnewfile = stdin;
	else
		if ((pnewfile = fopen(argv[2], "r")) == NULL) {
			snprintf(Error, sizeof (Error),
				"Can not open '%s'", argv[2]);
			fatal(Error);
		}

	seglim = 3500;

	if (argc > 3) {
		if (argv[3][0] == '-' && argv[3][1] == 's')
			Fflags &= ~FTLMSG;
		else {
			if ((seglim = atoi(argv[3])) == 0)
				fatal("non-numeric limit");
			if (argc == 5 && argv[4][0] == '-' &&
					argv[4][1] == 's')
				Fflags &= ~FTLMSG;
		}
	}

	linenum = 0;

	/* Allocate the buffers and initialize their lengths */

	obufsiz = BUFSIZ;
	nbufsiz = BUFSIZ;
	dbufsiz = BUFSIZ;

	if ((oline = (char *)malloc(obufsiz)) == NULL ||
	    (nline = (char *)malloc(nbufsiz)) == NULL ||
	    (diffline = (char *)malloc(dbufsiz)) == NULL)
		fatal("Out of memory");

	/*
	 * The following while-loop will prevent any lines
	 * common to the beginning of both files from being
	 * sent to 'diff'. Since the running time of 'diff' is
	 * non-linear, this will help improve performance.
	 * If, during this process, both files reach EOF, then
	 * the files are equal and the program will terminate.
	 * If either file reaches EOF before the other, the
	 * program will generate the appropriate 'diff' output
	 * itself, since this can be easily determined and will
	 * avoid executing 'diff' completely.
	 */
	while (1) {
		olp = readline(&oline, &obufsiz, poldfile);
		nlp = readline(&nline, &nbufsiz, pnewfile);

		if (!olp && !nlp)	/* EOF found on both:  files equal */
			exit(0);

		if (!olp) {
			/*
			 * The entire old file is a prefix of the
			 * new file. Generate the appropriate "append"
			 * 'diff'-like output, which is of the form:
			 * 		nan, n
			 * where 'n' represents a line-number.
			 */
			addgen(&nline, &nbufsiz, pnewfile);
		}

		if (!nlp) {
			/*
			 * The entire new file is a prefix of the
			 * old file. Generate the appropriate "delete"
			 * 'diff'-like output, which is of the form:
			 * 		n, ndn
			 * where 'n' represents a line-number.
			 */
			delgen(&oline, &obufsiz, poldfile);
		}

		if (strcmp(olp, nlp) == 0)
			linenum++;
		else
			break;
	}

	/*
	 * Here, first 'linenum' lines are equal.
	 * The following while-loop segments both files into
	 * seglim segments, forks and executes 'diff' on the
	 * segments, and processes the resulting output of
	 * 'diff', which is read from a pipe.
	 */
	while (1) {
		/* If both files are at EOF, everything is done. */
		if (!olp && !nlp)	/* finished */
			exit(0);

		if (!olp) {
			/*
			 * Generate appropriate "append"
			 * output without executing 'diff'.
			 */
			addgen(&nline, &nbufsiz, pnewfile);
		}

		if (!nlp) {
			/*
			 * Generate appropriate "delete"
			 * output without executing 'diff'.
			 */
			delgen(&oline, &obufsiz, poldfile);
		}

		/*
		 * Create a temporary file to hold a segment
		 * from the old file, and write it.
		 */
		poldtemp = maket(otmp);
		otcnt = 0;
		while (olp && otcnt < seglim) {
			fputs(oline, poldtemp);
			if (ferror(poldtemp) != 0) {
				Fflags |= FTLMSG;
				fatal("Can not write to temporary file");
			}
			olp = readline(&oline, &obufsiz, poldfile);
			otcnt++;
		}
		fclose(poldtemp);

		/*
		 * Create a temporary file to hold a segment
		 * from the new file, and write it.
		 */
		pnewtemp = maket(ntmp);
		ntcnt = 0;
		while (nlp && ntcnt < seglim) {
			fputs(nline, pnewtemp);
			if (ferror(pnewtemp) != 0) {
				Fflags |= FTLMSG;
				fatal("Can not write to temporary file");
			}
			nlp = readline(&nline, &nbufsiz, pnewfile);
			ntcnt++;
		}
		fclose(pnewtemp);

		/* Create pipes and fork.  */
		if ((pipe(pfd)) == -1)
			fatal("Can not create pipe");
		if ((i = fork()) < (pid_t)0) {
			close(pfd[0]);
			close(pfd[1]);
			fatal("Can not fork, try again");
		} else if (i == (pid_t)0) {	/* child process */
			close(pfd[0]);
			close(1);
			dup(pfd[1]);
			close(pfd[1]);

			/* Execute 'diff' on the segment files. */
			execlp(diff, diff, otmp, ntmp, 0);

			/*
			 * Exit code here must be > 1.
			 * Parent process treats exit code of 1 from the child
			 * as non-error because the child process "diff" exits
			 * with a status of 1 when a difference is encountered.
			 * The error here is a true error--the parent process
			 * needs to detect it and exit with a non-zero status.
			 */
			close(1);
			sprintf(Error, "Can not execute '%s'", diff);
			fatal_num = 2;
			fatal(Error);
		} else {			/* parent process */
			close(pfd[1]);
			pipeinp = fdopen(pfd[0], "r");

			/* Process 'diff' output. */
			while ((dp = readline(&diffline, &dbufsiz, pipeinp))) {
				if (isdigit(*dp))
					fixnum(diffline);
				else
					printf("%s", diffline);
			}

			fclose(pipeinp);

			/* EOF on pipe. */
			wait(&status);
			if (status&~0x100) {
				sprintf(Error, "'%s' failed", diff);
				fatal(Error);
			}
		}
		linenum += seglim;

		/* Remove temporary files. */
		unlink(otmp);
		unlink(ntmp);
	}
}

/* Routine to save remainder of a file. */
void
saverest(char **linep, size_t *bufsizp, FILE *iptr)
{
	char *lp;
	FILE *temptr, *maket();

	temptr = maket(tempfile);

	lp = *linep;

	while (lp) {
		fputs(*linep, temptr);
		linenum++;
		lp = readline(linep, bufsizp, iptr);
	}
	fclose(temptr);
}

/* Routine to write out data saved by 'saverest' and to remove the file. */
void
putsave(char **linep, size_t *bufsizp, char type)
{
	FILE *temptr;

	if ((temptr = fopen(tempfile, "r")) == NULL) {
		sprintf(Error, "Can not open tempfile ('%s')", tempfile);
		fatal(Error);
	}

	while (readline(linep, bufsizp, temptr))
		printf("%c %s", type, *linep);

	fclose(temptr);

	unlink(tempfile);
}

void
fixnum(char *lp)
{
	off_t num;

	while (*lp) {
		switch (*lp) {

		case 'a':
		case 'c':
		case 'd':
		case ',':
		case '\n':
			printf("%c", *lp);
			lp++;
			break;

		default:
			lp = satoi(lp, &num);
			num += linenum;
			printf("%lld", num);
		}
	}
}

void
addgen(char **lpp, size_t *bufsizp, FILE *fp)
{
	off_t oldline;
	printf("%llda%lld", linenum, linenum+1);

	/* Save lines of new file. */
	oldline = linenum + 1;
	saverest(lpp, bufsizp, fp);

	if (oldline < linenum)
	    printf(",%lld\n", linenum);
	else
	    printf("\n");

	/* Output saved lines, as 'diff' would. */
	putsave(lpp, bufsizp, '>');

	exit(0);
}

void
delgen(char **lpp, size_t *bufsizp, FILE *fp)
{
	off_t savenum;

	printf("%lld", linenum+1);
	savenum = linenum;

	/* Save lines of old file. */
	saverest(lpp, bufsizp, fp);

	if (savenum +1 != linenum)
	    printf(",%lldd%lld\n", linenum, savenum);
	else
	    printf("d%lld\n", savenum);

	/* Output saved lines, as 'diff' would.  */
	putsave(lpp, bufsizp, '<');

	exit(0);
}

void
clean_up()
{
	unlink(tempfile);
	unlink(otmp);
	unlink(ntmp);
}

FILE *
maket(char *file)
{
	FILE *iop;
	int fd;

	(void) strcpy(file, tempskel);
	if ((fd = mkstemp(file)) == -1 ||
		(iop = fdopen(fd, "w+")) == NULL) {
		sprintf(Error, "Can not open/create temp file ('%s')", file);
		fatal(Error);
	}
	return (iop);
}

void
fatal(char *msg)
/*
 *	General purpose error handler.
 *
 *	The argument to fatal is a pointer to an error message string.
 *	The action of this routine is driven completely from
 *	the "Fflags" global word (see <fatal.h>).
 *
 *	The FTLMSG bit controls the writing of the error
 *	message on file descriptor 2.  The message is preceded
 *	by the string "ERROR: ", unless the global character pointer
 *	"Ffile" is non-zero, in which case the message is preceded
 *	by the string "ERROR [<Ffile>]: ".  A newline is written
 *	after the user supplied message.
 *
 *	If the FTLCLN bit is on, clean_up is called.
 */
{
	if (Fflags & FTLMSG)
		fprintf(stderr, "%s: %s\n", prognam, msg);
	if (Fflags & FTLCLN)
		clean_up();
	if (Fflags & FTLEXIT)
		exit(fatal_num);
}

void
setsig()
/*
 *	General-purpose signal setting routine.
 *	All non-ignored, non-caught signals are caught.
 *	If a signal other than hangup, interrupt, or quit is caught,
 *	a "user-oriented" message is printed on file descriptor 2.
 *	If hangup, interrupt or quit is caught, that signal
 *	is set to ignore.
 *	Termination is like that of "fatal",
 *	via "clean_up()"
 */
{
	void setsig1();
	register int j, n;

	for (j = 1; j < ONSIG; j++) {
		n = (int) signal(j, setsig1);
		if ((void(*)())n == SIG_ERR)
			continue;
		if ((void(*)())n == SIG_DFL)
			continue;
		signal(j, (void(*)())n);
	}
}

void
setsig1(sig)
int sig;
{

	signal(sig, SIG_IGN);
	clean_up();
	exit(1);
}

char *
satoi(char *p, off_t *ip)
{
	off_t sum;

	sum = 0;
	while (isdigit(*p))
		sum = sum * 10 + (*p++ - '0');
	*ip = sum;
	return (p);
}

/*
 * Read a line of data from a file.  If the current buffer is not large enough
 * to contain the line, double the size of the buffer and continue reading.
 * Loop until either the entire line is read or until there is no more space
 * to be malloc'd.
 */

char *
readline(char **bufferp, size_t *bufsizp, FILE *filep)
{
	char * bufp;
	size_t newsize;		/* number of bytes to make buffer */
	size_t oldsize;

	(*bufferp)[*bufsizp - 1] = '\t'; /* arbitrary non-zero character */
	(*bufferp)[*bufsizp - 2] = ' ';	/* arbitrary non-newline char */
	bufp = fgets(*bufferp, *bufsizp, filep);
	if (bufp == NULL)
		return (bufp);
	while ((*bufferp)[*bufsizp -1] == '\0' &&
	    (*bufferp)[*bufsizp - 2] != '\n' &&
	    strlen(*bufferp) == *bufsizp - 1) {
		newsize = 2 * (*bufsizp);
		bufp = (char *)realloc((void *)*bufferp, newsize);
		if (bufp == NULL)
			fatal("Out of memory");
		oldsize = *bufsizp;
		*bufsizp = newsize;
		*bufferp = bufp;
		(*bufferp)[*bufsizp - 1] = '\t';
		(*bufferp)[*bufsizp - 2] = ' ';
		bufp = fgets(*bufferp + oldsize -1, oldsize + 1, filep);
		if (bufp == NULL) {
			if (filep->_flag & _IOEOF) {
				bufp = *bufferp;
				break;
			} else
				fatal("Read error");
		} else
			bufp = *bufferp;
	}
	return (bufp);
}

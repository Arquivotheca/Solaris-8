/*
 * Copyright (c) 1995-1999 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma ident	"@(#)main.c	1.66	99/08/19 SMI"

#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/fcntl.h>
#include <sys/reboot.h>
#include <sys/bootconf.h>
#include <sys/debug/debugger.h>
#if defined(i386)
#include <sys/reg.h>
#endif
#include "symtab.h"

#if defined(i386)
int kcmntrap;
int kxc_call;
int kxc_serv;
int psm_shutdownf;
int psm_notifyf;
int kadb_map;
int cpu_family;
int *xc_initted;
extern void kadb_mpinit();
extern struct regs *regsave;		/* temp reg save area on ministack */
int first_time;
extern int estack;
extern void init_bootops();
#else
#if defined(__ia64)
extern void init_bootops();
#endif /* __ia64 */
extern char estack[];
#endif	/* i386 */

extern int open();
extern char *rindex();
extern int debugcmd();
extern int open_platform_file();
extern int strncmp();
extern	int	printf();
extern	void	close();
extern	void	ttysync();
extern	void	spawn(char *, func_t);
extern	void	prom_exit_to_mon(void);
extern	void	free(void *);
extern	void	cmd();
extern	void	setbp();
extern	void	exitto();
extern	char	*strcpy();
extern	char	*strncpy();
extern	void	*malloc();

/*
 * These are here because the common code between adb and kadb in adb
 * uses them
 */
char *prompt = "kadb";
int cmd_line_prompt;
int kernelbase;
func_t go2;

#define	MALLOC_PAD	0x1000	/* malloc pad - XXX - should be PAGESIZE? */

int interactive = 0;			/* true if -d flag passed in */
static int mydirlen = 0;

void
#if defined(i386)
main(i_fp)
struct regs *i_fp;
#else
main()
#endif	/* i386 */
{
	func_t load_it();
	char *arg;
	extern int	executing;
#if defined(i386)
	func_t fake_bp();
	struct asym *asp;
	extern	int	i_fparray[];
	extern struct bootops *bopp;
	reg = regsave = i_fp;
#elif defined(__ia64)
	extern struct bootops *bopp;
#endif

	ttysync();

#if defined(i386) || defined(__ia64)
	init_bootops(bopp);
#endif

	spawn((char *)estack, debugcmd);
	while ((go2 = load_it(&arg)) == (func_t)-1)
		continue;
	if (go2 == (func_t)-2)
		prom_exit_to_mon();

	free(malloc(MALLOC_PAD));

	printf("%s loaded - 0x%x bytes used\n",
	    arg, mmu_ptob(pagesused));

#if defined(i386)
	if ((asp = lookup("kernelbase")) != 0) {
		kernelbase = asp->s_value;
	} else
		kernelbase = 0xf8000000;
	if ((asp = lookup("cmntrap")) != 0) {
		kcmntrap = asp->s_value;
	}
	xc_initted = NULL;
	if ((asp = lookup("xc_call_kadb")) != 0) {
		kxc_call = asp->s_value;
		if ((asp = lookup("xc_serv")) != 0) {
			kxc_serv = asp->s_value;
			if ((asp = lookup("xc_initted")) != 0) {
				xc_initted = (int *)(asp->s_value);
			}
		}
	}
	if ((asp = lookup("psm_shutdownf")) != 0) {
		psm_shutdownf = asp->s_value;
	}
	if ((asp = lookup("psm_notifyf")) != 0) {
		psm_notifyf = asp->s_value;
	}
	if ((asp = lookup("kadb_mpinit_ptr")) != 0) {
		*(int *)asp->s_value = (int)kadb_mpinit;
	}
	if ((asp = lookup("i_fparray_ptr")) != 0) {
		*(int *)asp->s_value = (int)i_fparray;
	}
	if ((asp = lookup("kadb_map")) != 0) {
		kadb_map = asp->s_value;
	}
	if ((asp = lookup("cpu_family")) != 0) {
		cpu_family = asp->s_value;
	}
	first_time = 1;
	i_fp->r_eip = (int)&fake_bp;
#elif !defined(__ia64)
	/*
	 * We cannot do lookup() here since the sparc will not let us
	 * do lookup util we switch stacks to our own (at this point we're
	 * still running on the PROM's stack). The switch is done in
	 * cmd().
	 *
	 * XXX - the above is not true - we currently do some lookups in
	 * readfile().
	 */
	kernelbase = KERNELBASE;	/* XXX FIXME */
	if (interactive & RB_KRTLD) {
		cmd();
		if (dotrace) {
			scbstop = 1;
			dotrace = 0;
		}
	}
#endif
	nobrk = 1;		/* no more sbrk's allowed */

	if (interactive & RB_DEBUG) {
		setbp();
		executing = 1;
	}

	exitto(go2);
	/*NOTREACHED*/
}

/*
 * Just a funny way to `stat' the pathname...
 */
static int
test_file(char *pathname)
{
	int fd;

	if ((fd = open(pathname, O_RDONLY)) >= 0) {
		close(fd);
		return (1);
	} else {
		return (0);
	}
}

/* dir path comparison routine for myname */
/* ARGSUSED1 */
static int
cmp_mydir(char *platdir, void *junk)
{
	if (strncmp(myname, platdir, mydirlen))
		return (-1);
	return (0);
}

/*
 * if the leading dir path of myname is non-standard,
 * check for filename relative to that dir
 */
static int
custom_path(char *filename, char *pathname)
{
	char *cp;

	if ((cp = rindex(myname, '/')) == NULL)
		return (0);

	/*
	 * here we don't actually open anything, instead passing in
	 * a routine to compare the strings "/platform/<impl>/"
	 * generated by get_impl_arch_name() / make_platform_path()
	 */
	mydirlen = (int)(cp - myname) + 1;
	if (open_platform_file("", cmp_mydir, 0, pathname, NULL) == 0)
		return (0);

	(void) strncpy(pathname, myname, (size_t)mydirlen);
	(void) strcpy(&pathname[mydirlen], filename);
	if (test_file(pathname)) {
		(void) strcpy(filename, pathname);
		return (1);
	}

	return (0);
}

/*
 * Construct the appropriate pathname for the object
 * to be debugged (usually the kernel)
 *
 * first check if filename is absolute,
 * then check if the kadb pathname is non-standard,
 * and fallback to platform pathnames.
 */
int
get_path_name(char *filename)
{
	char pathname[LINEBUFSZ];
	int fd;

	/*
	 * First, if the name specified begins with a slash and the
	 * file exists, use that name without modification.  If the
	 * absolute path name is non-existent, return an error and
	 * have the user try again.
	 */
	if (*filename == '/') {
		if (test_file(filename)) {
			return (0);
		} else {
			return (1);
		}
	}

	if (custom_path(filename, pathname))
		return (0);

	fd = open_platform_file(filename, open, O_RDONLY, pathname, NULL);
	if (fd != -1) {
		strcpy(filename, pathname);
		close(fd);
		return (0);
	} else {
		return (1);
	}
}

ka_main_loop(char c)
{
	printf("Command not available\n");
	return (0);
}

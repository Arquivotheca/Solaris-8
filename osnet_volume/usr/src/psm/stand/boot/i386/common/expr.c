/*
 * Copyright (c) 1992-1996, Sun Microsystems, Inc.  All Rights Reserved.
 */

#ident "@(#)expr.c	1.3	96/03/23 SMI"

/* expression evaluation for set/if/else/elseif/endif */

#include <sys/bsh.h>
#include <sys/types.h>
#include <sys/salib.h>
#include "y.tab.h"	/* generated by yacc */

extern int yyparse();

#define	END	0
#define	LCASEBIT    0x20

/* globals for communication with expression parser and lexical analyzer */
int	expr_value;
int	lex_argc;
char	**lex_argv;


/* expr() - evaluates expressions for set, if and elseif */

int
expr(int argc, char *argv[])
{
	if (argc == 0)
		return (0);
	lex_argc = argc;
	lex_argv = argv;
	if (yyparse()) {
		printf("boot: expression syntax error\n");
		return (0);
	}
	return (expr_value);
}


/* yylex() - lexical analyzer called by expression parser */

int
yylex()
{
	register char *cp;
	char *arg;

	yylval.intval = 0;	/* default value */
	if (lex_argc == 0)
		return (END);
	--lex_argc;
	cp = arg = *lex_argv++;

	switch (*cp++) {

	case '|':
		switch (*cp++) {
		case '\0':
			return (OR);
		case '|':
			switch (*cp++) {
			case '\0':
				return (OROR);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '&':
		switch (*cp++) {
		case '\0':
			return (AND);
		case '&':
			switch (*cp++) {
			case '\0':
				return (ANDAND);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '!':
		switch (*cp++) {
		case '\0':
			return (NOT);
		case '=':
			switch (*cp++) {
			case '\0':
				return (NE);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '=':
		switch (*cp++) {
		case '\0':
			goto ret_str;
		case '=':
			switch (*cp++) {
			case '\0':
				return (EQ);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '>':
		switch (*cp++) {
		case '\0':
			return (GT);
		case '>':
			switch (*cp++) {
			case '\0':
				return (SHR);
			default:
				goto ret_str;
			}
		case '=':
			switch (*cp++) {
			case '\0':
				return (GE);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '<':
		switch (*cp++) {
		case '\0':
			return (LT);
		case '<':
			switch (*cp++) {
			case '\0':
				return (SHL);
			default:
				goto ret_str;
			}
		case '=':
			switch (*cp++) {
			case '\0':
				return (LE);
			default:
				goto ret_str;
			}
		default:
			goto ret_str;
		}

	case '+':
		switch (*cp++) {
		case '\0':
			return (PLUS);
		default:
			goto ret_str;
		}

	case '-':
		switch (*cp++) {
		case '\0':
			return (MINUS);
		default:
			goto ret_str;
		}

	case '*':
		switch (*cp++) {
		case '\0':
			return (MUL);
		default:
			goto ret_str;
		}

	case '/':
		switch (*cp++) {
		case '\0':
			return (DIV);
		default:
			goto ret_str;
		}

	case '%':
		switch (*cp++) {
		case '\0':
			return (MOD);
		default:
			goto ret_str;
		}

	case '~':
		switch (*cp++) {
		case '\0':
			return (COMPL);
		default:
			goto ret_str;
		}

	case '(':
		switch (*cp++) {
		case '\0':
			return (LPAREN);
		default:
			goto ret_str;
		}

	case ')':
		switch (*cp++) {
		case '\0':
			return (RPAREN);
		default:
			goto ret_str;
		}

	case ',':
		switch (*cp++) {
		case '\0':
			return (COMMA);
		default:
			goto ret_str;
		}

	case '\\':	/* backslash quotes a string */
		++arg;
		goto ret_str;

	case '.':	/* dot builtin functions */
		if (strcmp(cp, "strfind") == 0)
			return (STRFIND);
		else if (strcmp(cp, "strcmp") == 0)
			return (STRCMP);
		else if (strcmp(cp, "strncmp") == 0)
			return (STRNCMP);
		else if (strcmp(cp, "streq") == 0)
			return (STREQ);
		else if (strcmp(cp, "strneq") == 0)
			return (STRNEQ);
		else
			goto ret_str;

	}

ret_str: /* return string pointer value */

	yylval.strval = arg;
	return (STRING);
}


/* findstr() - find a string within an address range */

findstr(str, addr, n)
	char *str, *addr;
	int n;
{
	char *cp1, c1, *cp2;

	for (; --n >= 0; ++addr) {
		for (cp1 = str, cp2 = addr; ; ) {
			if ((c1 = *cp1++) == '\0')
				return ((int)addr);
			else if (c1 != *cp2++)
				break;
		}
	}
	return (0);
}

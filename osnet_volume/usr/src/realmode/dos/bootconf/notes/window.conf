
Window System Configuration:
----------------------------

    Configuration details of four separate devices must be made available to
    the windowing system:

     1.	The keyboard:  All PCs use (essentially) the same keyboard.  Support
	for different languages is implemented by changing keycaps and map-
	ping keystroke codes to the corresponding characters.  The problem
	is figuring out which keystroke map one should be using.

     2. The mouse.  There are three major types (serial, bus, PS/2) with a
	number of options (MS protocol, MSC protocol, 2-button, 3-button, etc).

     3. The video board:  Lots of different models and manufacturers, each
	with its own peculiarities.

     4. The monitor:  One needs to know the total screen area so as to gen-
	erate pixles of the appropriate size.

    Ideally, the windowing system should be able to get all of the neccessary
    configuration information from the device tree (just as it does on SPARC
    machines).  The challange for bootconf, then, is to get this information
    into the device tree in the first place.

    Given the large number of configuration options available on x86 machines,
    encoding a complete windowing configuration in a device tree's node name
    (as is done for SPARC) seems a bit unwieldy.  I makes much more sense to
    include configuration details as properties on one or more device nodes
    instead (which introduces the need for a means of exporting device 
    properties, which are kernel data structures, to a user-mode X server --
    but that's not bootconf's problem).

    In order to implement this scheme, bootconf's getprop/setprop callbacks
    have to be written (they're simple stubs right now).  There's already a
    "devprop" sturcture defined in "devdb.h" to carry property information
    and a "proplist" pointer in the device translation (i.e, "master" file)
    record to describe the default properties for devices of a given type
    (i.e, those extracted from the "master" file).  One simply needs to add
    a "proplist" to the board record to hold device-specific properties
    generated by the driver callbacks, and then change the "build_tree"
    routine to generate device tree property lists from the board records
    rather than the device translation records.  The following complications
    must be addressed as well.

     1.	Changing device names:  When the legacy probe routine issues a
	NODE_START callback, the framework creates a board record and init-
	ializes it with default information - including the EISA device name
	as extracted from the device translation record.  Obviously, any
	default properties should be added to the node at this time as well.
	This gives the driver the opertunity to change the default properties
	based on the results of its probing operations.

	It is possible, however, for a driver to change the EISA device name
	of the node it's creating which could invalidate the current device
	translation.  The question then becomes, what does one do with the
	(possibly inappropriate) property list?  Personally, I think the
	solution is to wipe the board's property list clean, then locate the
	new device translation (if any) and re-initialize the list from
	there.

     2.	Persistance:  The real problem here is guaranteeing persistance of
	property lists across calls to bootconf.  Right now, all persistant
	configuration information is maintained in the ESCD file but the
	format of this file is dictated by the PnP spec and there's no way
	to extend it to include property list info (the ESCD is, itself, an
	extension of the EISA NVRAM format and PnP has already sucked up all
	the "reserved" encodings).  Thus we must either (a) forget about
	maintaining external compatibility with PnP and devise a new external
	file structure, or (b) carry persistant propertly list info in a
	parallel file.  While I personally prefer the former approach, pol-
	itical reality will probably dictate that we adapt the latter.

	I suggest that the external representation of device property lists
	be carried in a file whose base name matches that of the ESCD file,
	but with a different suffix.  If, for example, the ESCD file is
	"conf001.rf", the propertly list file could be "conf001.pl".  This
	will make it realatively easy to locate the external property list
	given the escd file (whose name is globally available within bootconf
	already).  The propertly list file would have to be read/written
	whenever the ESCD is read/written, of course.

	As to the format of the property list file, note that we already have
	a "keyword=value" prop list parser in "devdb.c" that can be used to
	build a list of "devprop" structs (n.b, it currently doesn't support
	quoting, so white space is always significant -- this may need to be
	fixed).  All that needs to be done is to figure out which "devprop"
	list goes with which board record.  Since board records are uniquely
	identified by slot number, I suggest a syntax like this:

	   <slot>:  <key1>=<value1> <key2>=<value2> ... <keyN>=<valueN>

	where "<slot>" is the numeric slot number of the board to which this
	property list belongs, and the "<key>"s and "<value>"s make up the
	property list itself.

    Without trying to come up with a comprehensive list of configuration
    properties required by the X server (or, for that matter, to even specify
    how many device nodes said properties should be spread across), here are
    some of the issues complicating the x86 window configuration problem and
    some suggestions as to how bootconf might work around them.

    Keyboard:
    ---------

	Currently, bootconf asks the user to select a keyboard mapping (using
	function keys which encode to the same values under all mappings) and
	includes the selected mapping in its description of the configuration.
	It then becomes a rather trivial matter to convert this to a property
	of the keyboard device node.

	The current selection screen can be enhanced a bit by including a
	"default key map" string in the language translation file (the 
        "bootconf.txt" file).  This string would be an ASCII numeric value
	that gives the index into the list of keyboard mappings that represents
	the most logical default keyboard mapping given the language in which
	the messages themselves are being displayed.  Thus, most users will
	be able to immediately press enter (i.e, select the default mapping)
	regardless of language (assuming, of course, they bought the right
	version of the product in the first place).

    Mouse:
    ------
	
	From reading Logitech specc, it appears that one should be able to
	determine all relevant properties of the pointing device by checking
	bios data and/or probing I/O ports.  Thus, it should be fairly easy
	for a half-BEF to determine appropriate mouse properties such as, e.g,
        "protocol=microsoft" or "buttons=2".  The problem is to which device
	node they should be associated.  Although it makes sense to tie them
	to the device node that actually controls the device, someone has
	to tell the X server where that node is (a serial mouse, for example,
	could be at "/isa/asy...", "/eisa/asy...", "/pci/asy...", or even
	"/pcmcia/asy..."!).  Given that there must be a "mouse=node"
	property at some standard place in the device tree, it might make
	sense to put other mouse properties there as well.

    Video:
    ------

	This is, by far, the trickiest part of configuring the windowing
	system.  Determining the video configuration is going to be a rather
	ad-hoc process, so it makes sense to push this code off into a video
	half-bef.  There are two major techniques availalble to this driver
	to identify the video card:


	 1. BIOS scanning:  Standard BIOS data registers can be used to de-
	    termine whether or not the system supports a video card at all,
	    and wether said card is VGA or better.  So far so good, but
	    we have to do a lot better than this.  Fortunately, all SVGA
	    cards also include an on-board BIOS extension ROM which may
	    include a manufacturer's signature which, in turn, may be used
	    to identify the device type.  It should be possible, therefore,
	    to design a "signature table" for use by an interpreter in the
	    video half-bef.  An example might look something like this:

		0x100-0x3FF: "ATI Graphics Wonder" name=ATI1000 chip=Mach32 ...
		0x000-0xFFF: "Genoa ([^ ]*)$1" name=$1 ...
		0x000-0xFFF: "Foobax 1234" name=FOO1234 +3

	    The first field gives the range of ROM addresses (relative to the
	    base of the video BIOS extension as determined by the driver) in
	    which the driver is to look for the signature and the second field
	    is a regular expression that matchs the signature.  The remaining
	    remaining fields (except for the optional trailing "+N", see below)
	    constitute the property list that's applied to the device node if
	    the signatures match.  Note how "regex"-like pattern assignments
	    can be used to transfer parts of the signature to the property list
	    (as in the "Genoa" example, above).

	    The video driver would scan the BIOS extension applying each
	    signature expression in turn.  As soon as a match is found, the
	    corresponding property list is extracted and can then be added
	    to the device node via bootconf's setprop/getprop callbacks.
	    The driver might also key off of particular properties (e.g,
	    "name=") and perform other generic actions (e.g, "set_res(name,
	    ...)") as well.

	    The signature table itself could be an entry in the "bootconf.txt"
	    file where the video driver can get to it via the "gettext" call-
	    back.  Thus, as new video cards are supported they can be added
	    to bootconf's repetuair of known devices by simply adding a line
	    to the "bootconf.txt" file.

	 2. If the BIOS scan fails to deterimine the type video card, it may
	    may still be possible to identify the card via more traditional
	    (i.e, more invasive) probing techniques.  There's a big problem
	    with this approach, however: It chan wedge the console!  Fort-
	    unately, most probe crashes can be avoided if the driver knows
	    something about the card (e.g, whether or not all 16 bits of the
	    port address are decoded by the card).  If this information can
	    be extracted from the BIOS extension, the driver may then know
	    that it's safe to probe particular ports.

	    If the driver matches on a BIOS signature line ending in "+N",
	    it runs the "N"th hard probe sequence to complete the video
	    property list.  Obviously, these probe sequences must be hard
	    coded into the driver itself, and are therefore not as extensible
	    as the BIOS signature mechanism proper.  Still, the "+N" trailer
	    provides the escape hatch needed to handle the nasty special cases
	    that always arise.

	One other problem with video configuration concerns PCI video cards.
	Right now, the PCI enumerator adds these to the configuration without
	attempting to determine any special properties the card might have.
	I suggest, instead, that the PCI enumerator ignore all such cards and
	let the video-half bef configure them instead (much as we currently
	do for PCI IDE controllers).  This means, of course, that the video
	driver must be prepared to change the device's bus type (the callback
	mechanism is set up to do this, but it's never been tested).

	There's also "feature" of most PCI video cards that they almost always
	conflict with the motherboard.  This is because they include a memory
	address in the range 0x0000-0xFFFFF.  I suspect that this is supposed
	to represent the memory occupied by the card's BIOS ROM extension.  If
	so, it should lie somewhere between 0xA0000 and 0xF0000, but the PCI
	enumerator (or the card itslef) wants to reserve all of low memory
	instead.  This bug needs to be fixed, but I'd fix it in the video
	half-bef rather than in the PCI enumerator.
	
    Display:
    --------

	This is the simplest for bootconf to deal with.  Aside from asking
	the user to manually enter the screen size (much as kdmconfig does
	today), there's nothing that bootconf can do about it.

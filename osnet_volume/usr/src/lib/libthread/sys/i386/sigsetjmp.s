        .file   "sigsetjmp.s"

	.ident "@(#)sigsetjmp.s	1.2	97/06/06"

/       The initial portion of sigsetjmp() is implemented in assembly language
/	because it needs to save the caller's context (explained below).
/	The latter part of sigsetjmp() is written in C, in the routine:
/	__csigsetjmp().
/
/	Details:
/	On x86, some of the caller's context such as %ebx, the pointer to
/	the Global Offset Table, is saved on entry to a C routine, by the
/	C compiler and changed to point to the appropriate GOT value 
/	(for libthread in this case). If sigsetjmp were to be written in C,
/	the caller's value of %ebx would have changed by the time 
/	sigsetjmp() is entered. Hence the wrong value of %ebx would
/	be obtained in a call to getcontext() inside sigsetjmp - and hence
/	the wrong value of %ebx would be stored into "env", the first arg to
/	sigsetjmp(). Later, when siglongjmp() is called on "env", it will
/	restore the caller's context but with the wrong value of %ebx - thus
/	after the longjmp, you would see gibberish when referring to global
/	data. See bugid	1255272. The same applies to the %edi and %esi
/	registers.
/
/	If one were to rely on the place on the stack that the compiler
/	saves %ebx, %esi and %edi, one could implement sigsetjmp() in C, and
/	then obtain the correct value of %ebx by reading it off the stack.
/	The place on the stack is (C routine's frame pointer - 12) in the
/	current	version of the x86 compiler. This should be evident from the
/	function prologue generated by the C compiler shown below:
/	
/	_sigsetjmp:
/		pushl   %ebp
/		movl    %esp,%ebp	/ ebp == frame pointer
/		pushl   %edi		/ so edi == %ebp - 4
/		pushl   %esi		/ so esi == %ebp - 8
/		pushl   %ebx		/ save %ebx, the caller's GOT pointer
/					/ so ebx == %ebp - 12
/		call    .L3
/	.L3:
/		popl    %ebx		/ store new GOT pointer into %ebx
/		addl    $_GLOBAL_OFFSET_TABLE_+[.-.L3],%ebx 
/	
/	... Now, the caller's GOT pointer may be obtained by calling
/	... _getfp(), thus obtaining the frame pointer (%ebp) and then
/	... reading the word beginning at (%ebp - 12)
/	
/	But the above technique is dependent on the C compiler which may
/	change	the position on the stack where it pushes %ebx, %edi and %esi
/	- the x86 ABI does not specify the exact place where these registers
/	should be pushed. So, the only option is to code it in assembler, and
/	not change anything (such as %ebx) in the assembly routine - or if you
/	do, then save and restore it.

#include "assym.s"
#include "i386/SYS.h"

/ _sigsetjmp() needs to do two things:
/	1. save the caller's thread signal mask into "env"; not the LWP mask
/	   obtained via a call to getcontext(2). After calling getcontext()
/	   to get the context, the uc_sigmask field in the ucontext is
/	   changed by _sigsetjmp() to be equal to the thread's signal mask.
/	2. fix up "env" to contain the correct values for the following
/	   registers specified by the SVR4 x86 ABI as protected:
/		%ebx, %ebp, %edi, %esi, and of course %esp
/	   In the following, the caller's %ebx, %ebp, %edi and %esi are not
/	   modified before the call to __getcontext(). But the caller's stack
/	   pointer (%uesp) has to be fixed up. Also, the return pc (%eip) and
/	   the return value (%eax) after the siglongjmp(), need to be fixed up.
/
/ NOTE:	   The fix-up of %uesp, %eax, and %eip is done in assembler below.
/	   If the savemask argument is set, then the fix-up of %eip and the
/	   setting of the thread signal mask, is done inside the C routine:
/	   __csigsetjmp().
/
/ int _sigsetjmp(sigjmp_buf env,int savemask)
/
fwdef(sigsetjmp)
        movl    4(%esp),%ecx    / ucp = (ucontext_t *)env;
        movl    $UC_ALL,(%ecx)  / ucp->uc_flags = UC_ALL;
        pushl   %ecx    	/ ucp
        pushl   $0      	/ GETCONTEXT
        pushl   %ecx    	/ dummy return addr
        movl    $SYS_context,%eax
        lcall   $SYSCALL_TRAPNUM,$0 / __getcontext(ucp);
        addl    $0xC,%esp

        movl    $1,UC_EAX(%ecx) / ucp->uc_mcontext.gregs[ EAX ] = 1;

        cmpl    $0,8(%esp)      / if (!savemask)
        jnz     .mask
        andl    $-1!UC_SIGMASK,(%ecx)   / ucp->uc_flags &= ~UC_SIGMASK;
        leal    4(%esp),%eax    / ucp->uc_mcontext.gregs[ UESP ] = caller's ESP
        movl    %eax,UC_UESP(%ecx)
        movl    0(%esp),%eax    / ucp->uc_mcontext.gregs[ EIP ] = caller's EIP
        movl    %eax,UC_EIP(%ecx)
        xorl    %eax,%eax
        ret
.mask:
	/ First, save the current stack pointer. The value of sp stored is
	/ different from the one stored above for the no mask case. This is
	/ because for the mask case, __csigsetjmp() sets up the setjmp buf to
	/ start at a different function, and not to the caller of _sigsetjmp().
	/ Hence the stack should be as if this function had been called, which
	/ would be at the same position as the current stack, which is after
	/ _sigsetjmp() has been called.

	/ ucp->uc_mcontext.gregs[ UESP ] = callee's ESP
        movl    %esp,UC_UESP(%ecx) 
        pushl   %ebx    / save GOT pointer
        call    .cfun
.cfun:
        popl    %ebx    / pop return pc from stack
        / compute new GOT value into %ebx, prologue to a function call
        addl    $_GLOBAL_OFFSET_TABLE_+[.-.cfun], %ebx
        movl    4(%esp),%edx    / get caller's EIP
	pushl	%edx		/ push caller's EIP as second argument.
        pushl   %ecx    	/ push ucontext pointer onto stack
        call    __csigsetjmp@PLT
        addl    $8, %esp        / pop csigsetjmp's arg
        popl    %ebx    / restore %ebx
        xorl    %eax, %eax
        ret


/ A much faster version of sigsetjmp() is included below
/ to be used later when risk is not a big issue (e.g. early
/ in the release cycle


/fwdef(sigsetjmp)
/	movl    4(%esp),%ecx    / ucp = (ucontext_t *)env;
/	movl    $UC_ALL,(%ecx)
/       movl    $1,UC_EAX(%ecx) / cpup[ EAX ] = 1;

/	movl	%ebp, UC_EBP(%ecx) / cpup [ EBP ] = %ebp
/	movl	%ebx, UC_EBX(%ecx) / cpup [ EBX ] = %ebx
/	movl	%edi, UC_EDI(%ecx) / cpup [ EDI ] = %edi
/	movl	%esi, UC_ESI(%ecx) / cpup [ ESI ] = %esi

/	movw	%ds, UC_DS(%ecx)
/	movw	%es, UC_ES(%ecx)
/	movw	%fs, UC_FS(%ecx)
/	movw	%gs, UC_GS(%ecx)
/	movw	%cs, UC_CS(%ecx)
/	movw	%ss, UC_SS(%ecx)
/	
/	cmpl    $0,8(%esp)      / if (!savemask)
/	jnz     .mask
/	andl    $-1!UC_SIGMASK,(%ecx)   /  ucp->uc_flags &= ~UC_SIGMASK;
/	movl    0(%esp),%eax    / ucp->uc_mcontext.gregs[EIP] = caller's EIP
/	movl    %eax,UC_EIP(%ecx)
/	leal    4(%esp),%eax    / ucp->uc_mcontext.gregs[UESP] = caller's ESP
/	movl    %eax,UC_UESP(%ecx)
/	xorl    %eax,%eax
/	ret
/.mask:
/	movl    %esp,UC_UESP(%ecx) / ucp->uc_mcontext.gregs[UESP] = callee's ESP
/	pushl   %ebx    / save GOT pointer
/	call    .cfun
/.cfun:
/	popl    %ebx    / pop return pc from stack
        / compute new GOT value into %ebx, prologue to a function call
/	addl    $_GLOBAL_OFFSET_TABLE_+[.-.cfun], %ebx
/	movl    4(%esp),%edx    / get caller's EIP
/	pushl	%edx		/ push caller's EIP as second argument.
/	pushl   %ecx    	/ push ucontext pointer onto stack
/	call    __csigsetjmp@PLT
/	addl    $8, %esp        / pop csigsetjmp's arg
/	popl    %ebx    / restore %ebx
/	xorl    %eax, %eax
/	ret

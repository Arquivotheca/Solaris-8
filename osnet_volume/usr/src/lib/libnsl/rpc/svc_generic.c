
/*
 * Copyright (c) 1986-1996,1997,1999 by Sun Microsystems Inc.
 * All rights reserved.
 */

#ident	"@(#)svc_generic.c	1.30	99/12/17 SMI"

#if !defined(lint) && defined(SCCSIDS)
static char sccsid[] = "@(#)svc_generic.c 1.21 89/02/28 Copyr 1988 Sun Micro";
#endif

/*
 * svc_generic.c, Server side for RPC.
 *
 */

#include "rpc_mt.h"
#include <stdio.h>
#include <rpc/rpc.h>
#include <sys/types.h>
#include <rpc/trace.h>
#include <errno.h>
#include <syslog.h>
#include <rpc/nettype.h>
#include <malloc.h>
#include <string.h>
#include <stropts.h>

extern int t_getname();

extern int __svc_vc_setflag();

extern SVCXPRT *svc_dg_create_private();
extern SVCXPRT *svc_vc_create_private();
extern SVCXPRT *svc_fd_create_private();

extern bool_t __svc_add_to_xlist();
extern void __svc_free_xlist();

/*
 * The highest level interface for server creation.
 * It tries for all the nettokens in that particular class of token
 * and returns the number of handles it can create and/or find.
 *
 * It creates a link list of all the handles it could create.
 * If svc_create() is called multiple times, it uses the handle
 * created earlier instead of creating a new handle every time.
 */

/* VARIABLES PROTECTED BY xprtlist_lock: xprtlist */

SVCXPRT_LIST *_svc_xprtlist = NULL;
extern mutex_t xprtlist_lock;

void
__svc_free_xprtlist()
{
	__svc_free_xlist(&_svc_xprtlist, &xprtlist_lock);
}

int
svc_create(dispatch, prognum, versnum, nettype)
	void (*dispatch)();	/* Dispatch function */
	rpcprog_t prognum;		/* Program number */
	rpcvers_t versnum;		/* Version number */
	const char *nettype;		/* Networktype token */
{
	SVCXPRT_LIST *l;
	int num = 0;
	SVCXPRT *xprt;
	struct netconfig *nconf;
	void *handle;
	bool_t try_others;
	int __rpc_try_doors();

	trace3(TR_svc_create, 0, prognum, versnum);
	/*
	 * Check if service should register over doors transport.
	 */
	if (__rpc_try_doors(nettype, &try_others)) {
		if (svc_door_create(dispatch, prognum, versnum, 0) == NULL)
			(void) syslog(LOG_ERR,
				"svc_create: could not register over doors");
		else
			num++;
	}
	if (!try_others)
		return (num);
	if ((handle = __rpc_setconf((char *) nettype)) == NULL) {
		(void) syslog(LOG_ERR, "svc_create: unknown protocol");
		trace3(TR_svc_create, 1, prognum, versnum);
		return (0);
	}
	while (nconf = __rpc_getconf(handle)) {
		mutex_lock(&xprtlist_lock);
		for (l = _svc_xprtlist; l; l = l->next) {
			if (strcmp(l->xprt->xp_netid, nconf->nc_netid) == 0) {
				/* Found an old one, use it */
				(void) rpcb_unset(prognum, versnum, nconf);
				if (svc_reg(l->xprt, prognum, versnum,
					dispatch, nconf) == FALSE)
					(void) syslog(LOG_ERR,
		"svc_create: could not register prog %d vers %d on %s",
					prognum, versnum, nconf->nc_netid);
				else
					num++;
				break;
			}
		}
		mutex_unlock(&xprtlist_lock);
		if (l == NULL) {
			/* It was not found. Now create a new one */
			xprt = svc_tp_create(dispatch, prognum, versnum, nconf);
			if (xprt) {
				if (!__svc_add_to_xlist(&_svc_xprtlist, xprt,
							&xprtlist_lock)) {
					(void) syslog(LOG_ERR,
						"svc_create: no memory");
					trace3(TR_svc_create, 1, prognum,
						versnum);
					return (0);
				}
				num++;
			}
		}
	}
	__rpc_endconf(handle);
	/*
	 * In case of num == 0; the error messages are generated by the
	 * underlying layers; and hence not needed here.
	 */
	trace3(TR_svc_create, 1, prognum, versnum);
	return (num);
}

/*
 * The high level interface to svc_tli_create().
 * It tries to create a server for "nconf" and registers the service
 * with the rpcbind. It calls svc_tli_create();
 */
SVCXPRT *
svc_tp_create(dispatch, prognum, versnum, nconf)
	void (*dispatch)();	/* Dispatch function */
	rpcprog_t prognum;	/* Program number */
	rpcvers_t versnum;	/* Version number */
	const struct netconfig *nconf; /* Netconfig structure for the network */
{
	SVCXPRT *xprt;

	trace3(TR_svc_tp_create, 0, prognum, versnum);
	if (nconf == (struct netconfig *)NULL) {
		(void) syslog(LOG_ERR,
	"svc_tp_create: invalid netconfig structure for prog %d vers %d",
				prognum, versnum);
		trace3(TR_svc_tp_create, 1, prognum, versnum);
		return ((SVCXPRT *)NULL);
	}
	xprt = svc_tli_create(RPC_ANYFD, nconf, (struct t_bind *)NULL, 0, 0);
	if (xprt == (SVCXPRT *)NULL) {
		trace3(TR_svc_tp_create, 1, prognum, versnum);
		return ((SVCXPRT *)NULL);
	}
	(void) rpcb_unset(prognum, versnum, (struct netconfig *) nconf);
	if (svc_reg(xprt, prognum, versnum, dispatch, nconf) == FALSE) {
		(void) syslog(LOG_ERR,
		"svc_tp_create: Could not register prog %d vers %d on %s",
				prognum, versnum, nconf->nc_netid);
		SVC_DESTROY(xprt);
		trace3(TR_svc_tp_create, 1, prognum, versnum);
		return ((SVCXPRT *)NULL);
	}
	trace3(TR_svc_tp_create, 1, prognum, versnum);
	return (xprt);
}

/*
 * If fd is RPC_ANYFD, then it opens a fd for the given transport
 * provider (nconf cannot be NULL then). If the t_state is T_UNBND and
 * bindaddr is NON-NULL, it performs a t_bind using the bindaddr. For
 * NULL bindadr and Connection oriented transports, the value of qlen
 * is set arbitrarily.
 *
 * If sendsz or recvsz are zero, their default values are chosen.
 */
SVCXPRT *
svc_tli_create(fd, nconf, bindaddr, sendsz, recvsz)
	register int fd;		/* Connection end point */
	const struct netconfig *nconf;	/* Netconfig struct for nettoken */
	const struct t_bind *bindaddr;	/* Local bind address */
	u_int sendsz;			/* Max sendsize */
	u_int recvsz;			/* Max recvsize */
{
	register SVCXPRT *xprt = NULL;	/* service handle */
	struct t_info tinfo;		/* transport info */
	struct t_bind *tres = NULL;	/* bind info */
	bool_t madefd = FALSE;		/* whether fd opened here  */
	int state;			/* state of the transport provider */

	trace4(TR_svc_tli_create, 0, fd, sendsz, recvsz);
	if (fd == RPC_ANYFD) {
		if (nconf == (struct netconfig *)NULL) {
			(void) syslog(LOG_ERR,
			"svc_tli_create: invalid netconfig");
			trace2(TR_svc_tli_create, 1, fd);
			return ((SVCXPRT *)NULL);
		}
		fd = t_open(nconf->nc_device, O_RDWR, &tinfo);
		if (fd == -1) {
			(void) syslog(LOG_ERR,
			"svc_tli_create: could not open connection for %s",
					nconf->nc_netid);
			trace2(TR_svc_tli_create, 1, fd);
			return ((SVCXPRT *)NULL);
		}
		madefd = TRUE;
		state = T_UNBND;
	} else {
		/*
		 * It is an open descriptor. Sync it & get the transport info.
		 */
		if ((state = t_sync(fd)) == -1) {
			(void) syslog(LOG_ERR,
		"svc_tli_create: could not do t_sync: %s",
					t_errlist[t_errno]);
			trace2(TR_svc_tli_create, 1, fd);
			return ((SVCXPRT *)NULL);
		}
		if (t_getinfo(fd, &tinfo) == -1) {
			(void) syslog(LOG_ERR,
		"svc_tli_create: could not get transport information");
			trace2(TR_svc_tli_create, 1, fd);
			return ((SVCXPRT *)NULL);
		}
	}

	/*
	 * If the fd is unbound, try to bind it.
	 * In any case, try to get its bound info in tres
	 */
/* LINTED pointer alignment */
	tres = (struct t_bind *)t_alloc(fd, T_BIND, T_ADDR);
	if (tres == NULL) {
		(void) syslog(LOG_ERR, "svc_tli_create: No memory!");
		goto freedata;
	}

	switch (state) {
	case T_UNBND:
		if (bindaddr) {
			if (t_bind(fd, (struct t_bind *) bindaddr,
								tres) == -1) {
				(void) syslog(LOG_ERR,
					"svc_tli_create: could not bind: %s",
						t_errlist[t_errno]);
				goto freedata;
			}
			/*
			 * Should compare the addresses only if addr.len
			 * was non-zero
			 */
			if (bindaddr->addr.len &&
				(memcmp(bindaddr->addr.buf, tres->addr.buf,
					(int)tres->addr.len) != 0)) {
				(void) syslog(LOG_ERR,
		"svc_tli_create: could not bind to requested address: %s",
						t_errlist[t_errno]);
				goto freedata;
			}
		} else {
			tres->qlen = 64; /* Chosen Arbitrarily */
			tres->addr.len = 0;
			if (t_bind(fd, tres, tres) == -1) {
				(void) syslog(LOG_ERR,
					"svc_tli_create: could not bind: %s",
						t_errlist[t_errno]);
				goto freedata;
			}
		}
		break;

	case T_IDLE:
		if (bindaddr) {
			/* Copy the entire stuff in tres */
			if (tres->addr.maxlen < bindaddr->addr.len) {
				(void) syslog(LOG_ERR,
				"svc_tli_create: illegal netbuf length");
				goto freedata;
			}
			tres->addr.len = bindaddr->addr.len;
			(void) memcpy(tres->addr.buf, bindaddr->addr.buf,
					(int)tres->addr.len);
		} else
			if (t_getname(fd, tres, LOCALNAME) == -1)
				tres->addr.len = 0;
		break;
	case T_INREL:
		(void) t_rcvrel(fd);
		(void) t_sndrel(fd);
		(void) syslog(LOG_ERR,
			"svc_tli_create: other side wants to\
release connection");
		goto freedata;

	case T_INCON:
		/* Do nothing here. Assume this is handled in rendezvous */
		break;
	case T_DATAXFER:
		/*
		 * This takes care of the case where a fd
		 * is passed on which a connection has already
		 * been accepted.
		 */
		if (t_getname(fd, tres, LOCALNAME) == -1)
			tres->addr.len = 0;
		break;
	default:
		(void) syslog(LOG_ERR,
		"svc_tli_create: connection in a wierd state (%d)", state);
		goto freedata;
	}

	/*
	 * call transport specific function.
	 */
	switch (tinfo.servtype) {
		case T_COTS_ORD:
		case T_COTS:
			if (state == T_DATAXFER)
				xprt = svc_fd_create_private(fd, sendsz,
						recvsz);
			else
				xprt = svc_vc_create_private(fd, sendsz,
						recvsz);
			if (!nconf || !xprt)
				break;
			if ((tinfo.servtype == T_COTS_ORD) &&
				(state != T_DATAXFER) &&
				(strcmp(nconf->nc_protofmly, "inet") == 0))
				(void) __svc_vc_setflag(xprt, TRUE);
			break;
		case T_CLTS:
			xprt = svc_dg_create_private(fd, sendsz, recvsz);
			break;
		default:
			(void) syslog(LOG_ERR,
			"svc_tli_create: bad service type");
			goto freedata;
	}
	if (xprt == (SVCXPRT *)NULL)
		/*
		 * The error messages here are spitted out by the lower layers:
		 * svc_vc_create(), svc_fd_create() and svc_dg_create().
		 */
		goto freedata;

	/* fill in the other xprt information */

	/* Assign the local bind address */
	xprt->xp_ltaddr = tres->addr;
	/* Fill in type of service */
	xprt->xp_type = tinfo.servtype;
	tres->addr.buf = NULL;
	(void) t_free((char *)tres, T_BIND);
	tres = NULL;

	xprt->xp_rtaddr.len = 0;
	xprt->xp_rtaddr.maxlen = __rpc_get_a_size(tinfo.addr);

	/* Allocate space for the remote bind info */
	if ((xprt->xp_rtaddr.buf = mem_alloc(xprt->xp_rtaddr.maxlen)) == NULL) {
		(void) syslog(LOG_ERR, "svc_tli_create: No memory!");
		goto freedata;
	}

	if (nconf) {
		xprt->xp_netid = strdup(nconf->nc_netid);
		if (xprt->xp_netid == NULL) {
			if (xprt->xp_rtaddr.buf)
				free(xprt->xp_rtaddr.buf);
			syslog(LOG_ERR, "svc_tli_create: strdup failed!");
			goto freedata;
		}
		xprt->xp_tp = strdup(nconf->nc_device);
		if (xprt->xp_tp == NULL) {
			if (xprt->xp_rtaddr.buf)
				free(xprt->xp_rtaddr.buf);
			if (xprt->xp_netid)
				free(xprt->xp_netid);
			syslog(LOG_ERR, "svc_tli_create: strdup failed!");
			goto freedata;
		}
	}

/*
	if (madefd && (tinfo.servtype == T_CLTS))
		(void) ioctl(fd, I_POP, (char *) NULL);
*/
	xprt_register(xprt);
	trace2(TR_svc_tli_create, 1, fd);
	return (xprt);

freedata:
	if (madefd)
		(void) t_close(fd);
	if (tres)
		(void) t_free((char *)tres, T_BIND);
	if (xprt) {
		if (!madefd) /* so that svc_destroy doesnt close fd */
			xprt->xp_fd = RPC_ANYFD;
		SVC_DESTROY(xprt);
	}
	trace2(TR_svc_tli_create, 1, fd);
	return ((SVCXPRT *)NULL);
}

/*
 * Copyright (c) 1998-1999 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma ident	"@(#)P32ton.c	1.3	99/11/01 SMI"

#include <sys/types.h>
#include <sys/mkdev.h>
#include <string.h>

#include "P32ton.h"

#ifdef _LP64

void
timestruc_32_to_n(const timestruc32_t *src, timestruc_t *dst)
{
	dst->tv_sec = (time_t)(uint32_t)src->tv_sec;
	dst->tv_nsec = (long)(uint32_t)src->tv_nsec;
}

void
stack_32_to_n(const stack32_t *src, stack_t *dst)
{
	dst->ss_sp = (caddr_t)src->ss_sp;
	dst->ss_size = src->ss_size;
	dst->ss_flags = src->ss_flags;
}

void
sigaction_32_to_n(const struct sigaction32 *src, struct sigaction *dst)
{
	(void) memset(dst, 0, sizeof (*dst));
	dst->sa_flags = src->sa_flags;
	dst->sa_handler = (void (*)())src->sa_handler;
	(void) memcpy(&dst->sa_mask, &src->sa_mask, sizeof (dst->sa_mask));
}

void
siginfo_32_to_n(const siginfo32_t *src, siginfo_t *dst)
{
	(void) memset(dst, 0, sizeof (*dst));

	/*
	 * The absolute minimum content is si_signo and si_code.
	 */
	dst->si_signo = src->si_signo;
	if ((dst->si_code = src->si_code) == SI_NOINFO)
		return;

	/*
	 * A siginfo generated by user level is structured
	 * differently from one generated by the kernel.
	 */
	if (SI_FROMUSER(src)) {
		dst->si_pid = src->si_pid;
		dst->si_uid = src->si_uid;
		if (SI_CANQUEUE(src->si_code)) {
			dst->si_value.sival_int =
			    (long)(uint32_t)src->si_value.sival_int;
		}
		return;
	}

	dst->si_errno = src->si_errno;

	switch (src->si_signo) {
	default:
		dst->si_pid = src->si_pid;
		dst->si_uid = src->si_uid;
		dst->si_value.sival_int =
		    (long)(uint32_t)src->si_value.sival_int;
		break;
	case SIGCLD:
		dst->si_pid = src->si_pid;
		dst->si_status = src->si_status;
		dst->si_stime = src->si_stime;
		dst->si_utime = src->si_utime;
		break;
	case SIGSEGV:
	case SIGBUS:
	case SIGILL:
	case SIGTRAP:
	case SIGFPE:
	case SIGEMT:
		dst->si_addr = (void *)(caddr32_t)src->si_addr;
		dst->si_trapno = src->si_trapno;
		dst->si_pc = (void *)(caddr32_t)src->si_pc;
		break;
	case SIGPOLL:
	case SIGXFSZ:
		dst->si_fd = src->si_fd;
		dst->si_band = src->si_band;
		break;
	case SIGPROF:
		dst->si_faddr = (void *)(caddr32_t)src->si_faddr;
		dst->si_tstamp.tv_sec = src->si_tstamp.tv_sec;
		dst->si_tstamp.tv_nsec = src->si_tstamp.tv_nsec;
		dst->si_syscall = src->si_syscall;
		dst->si_nsysarg = src->si_nsysarg;
		dst->si_fault = src->si_fault;
		break;
	}
}

void
auxv_32_to_n(const auxv32_t *src, auxv_t *dst)
{
	/*
	 * This is a little sketchy: we have three types of values stored
	 * in an auxv (long, void *, and void (*)()) so the only sign-extension
	 * issue is with the long.  We could case on all possible AT_* types,
	 * but this seems silly since currently none of the types which use
	 * a_un.a_val actually use negative numbers as a value.  For this
	 * reason, it seems simpler to just do an unsigned expansion for now.
	 */
	dst->a_type = src->a_type;
	dst->a_un.a_ptr = (void *)src->a_un.a_ptr;
}

void
rwindow_32_to_n(const struct rwindow32 *src, struct rwindow *dst)
{
	int i;

	for (i = 0; i < 8; i++) {
		dst->rw_local[i] = (uint64_t)(uint32_t)src->rw_local[i];
		dst->rw_in[i] = (uint64_t)(uint32_t)src->rw_in[i];
	}
}

void
gwindows_32_to_n(const gwindows32_t *src, gwindows_t *dst)
{
	int i;

	(void) memset(dst, 0, sizeof (gwindows_t));
	dst->wbcnt = src->wbcnt;

	for (i = 0; i < src->wbcnt; i++) {
		if (src->spbuf[i] != 0) {
			rwindow_32_to_n(&src->wbuf[i], &dst->wbuf[i]);
			dst->spbuf[i] = (greg_t *)src->spbuf[i];
		}
	}
}

void
prgregset_32_to_n(const prgreg32_t *src, prgreg_t *dst)
{
	int i;

	for (i = 0; i < NPRGREG; i++)
		dst[i] = (prgreg_t)(uint32_t)src[i];
}

void
prfpregset_32_to_n(const prfpregset32_t *src, prfpregset_t *dst)
{
	int i;

	(void) memset(dst, 0, sizeof (prfpregset_t));

	for (i = 0; i < 32; i++)
		dst->pr_fr.pr_regs[i] = src->pr_fr.pr_regs[i];

	/*
	 * We deliberately do not convert pr_qcnt or pr_q because it is a long-
	 * standing /proc bug that this information is not exported, and another
	 * bug further caused these values to be returned as uninitialized data
	 * when the 64-bit kernel exported them for a 32-bit process with en=0.
	 */
	dst->pr_filler = src->pr_filler;
	dst->pr_fsr = src->pr_fsr;
	dst->pr_q_entrysize = src->pr_q_entrysize;
	dst->pr_en = src->pr_en;
}

void
lwpstatus_32_to_n(const lwpstatus32_t *src, lwpstatus_t *dst)
{
	int i;

	dst->pr_flags = src->pr_flags;
	dst->pr_lwpid = src->pr_lwpid;
	dst->pr_why = src->pr_why;
	dst->pr_what = src->pr_what;
	dst->pr_cursig = src->pr_cursig;

	siginfo_32_to_n(&src->pr_info, &dst->pr_info);

	dst->pr_lwppend = src->pr_lwppend;
	dst->pr_lwphold = src->pr_lwphold;

	sigaction_32_to_n(&src->pr_action, &dst->pr_action);
	stack_32_to_n(&src->pr_altstack, &dst->pr_altstack);

	dst->pr_oldcontext = src->pr_oldcontext;
	dst->pr_syscall = src->pr_syscall;
	dst->pr_nsysarg = src->pr_nsysarg;
	dst->pr_errno = src->pr_errno;

	for (i = 0; i < PRSYSARGS; i++)
		dst->pr_sysarg[i] = (long)(uint32_t)src->pr_sysarg[i];

	dst->pr_rval1 = (long)(uint32_t)src->pr_rval1;
	dst->pr_rval2 = (long)(uint32_t)src->pr_rval2;

	(void) memcpy(&dst->pr_clname[0], &src->pr_clname[0], PRCLSZ);
	timestruc_32_to_n(&src->pr_tstamp, &dst->pr_tstamp);

	dst->pr_instr = src->pr_instr;

	prgregset_32_to_n(src->pr_reg, dst->pr_reg);
	prfpregset_32_to_n(&src->pr_fpreg, &dst->pr_fpreg);
}

void
pstatus_32_to_n(const pstatus32_t *src, pstatus_t *dst)
{
	dst->pr_flags = src->pr_flags;
	dst->pr_nlwp = src->pr_nlwp;
	dst->pr_pid = src->pr_pid;
	dst->pr_ppid = src->pr_ppid;
	dst->pr_pgid = src->pr_pgid;
	dst->pr_sid = src->pr_sid;
	dst->pr_aslwpid = src->pr_aslwpid;
	dst->pr_agentid = src->pr_agentid;
	dst->pr_sigpend = src->pr_sigpend;
	dst->pr_brkbase = src->pr_brkbase;
	dst->pr_brksize = src->pr_brksize;
	dst->pr_stkbase = src->pr_stkbase;
	dst->pr_stksize = src->pr_stksize;

	timestruc_32_to_n(&src->pr_utime, &dst->pr_utime);
	timestruc_32_to_n(&src->pr_stime, &dst->pr_stime);
	timestruc_32_to_n(&src->pr_cutime, &dst->pr_cutime);
	timestruc_32_to_n(&src->pr_cstime, &dst->pr_cstime);

	dst->pr_sigtrace = src->pr_sigtrace;
	dst->pr_flttrace = src->pr_flttrace;
	dst->pr_sysentry = src->pr_sysentry;
	dst->pr_sysexit = src->pr_sysexit;
	dst->pr_dmodel = src->pr_dmodel;

	lwpstatus_32_to_n(&src->pr_lwp, &dst->pr_lwp);
}

void
lwpsinfo_32_to_n(const lwpsinfo32_t *src, lwpsinfo_t *dst)
{
	dst->pr_flag = src->pr_flag;
	dst->pr_lwpid = src->pr_lwpid;
	dst->pr_addr = src->pr_addr;
	dst->pr_wchan = src->pr_wchan;
	dst->pr_stype = src->pr_stype;
	dst->pr_state = src->pr_state;
	dst->pr_sname = src->pr_sname;
	dst->pr_nice = src->pr_nice;
	dst->pr_syscall = src->pr_syscall;
	dst->pr_oldpri = src->pr_oldpri;
	dst->pr_cpu = src->pr_cpu;
	dst->pr_pri = src->pr_pri;
	dst->pr_pctcpu = src->pr_pctcpu;

	timestruc_32_to_n(&src->pr_start, &dst->pr_start);
	timestruc_32_to_n(&src->pr_time, &dst->pr_time);

	(void) memcpy(&dst->pr_clname[0], &src->pr_clname[0], PRCLSZ);
	(void) memcpy(&dst->pr_name[0], &src->pr_name[0], PRFNSZ);

	dst->pr_onpro = src->pr_onpro;
	dst->pr_bindpro = src->pr_bindpro;
	dst->pr_bindpset = src->pr_bindpset;
}

static dev_t
prexpldev(dev32_t d)
{
	if (d != (dev32_t)-1L)
		return (makedev((d >> NBITSMINOR32) & MAXMAJ32, d & MAXMIN32));

	return ((dev_t)PRNODEV);
}

void
psinfo_32_to_n(const psinfo32_t *src, psinfo_t *dst)
{
	dst->pr_flag = src->pr_flag;
	dst->pr_nlwp = src->pr_nlwp;
	dst->pr_pid = src->pr_pid;
	dst->pr_pgid = src->pr_pgid;
	dst->pr_sid = src->pr_sid;
	dst->pr_uid = src->pr_uid;
	dst->pr_euid = src->pr_euid;
	dst->pr_gid = src->pr_gid;
	dst->pr_egid = src->pr_egid;
	dst->pr_addr = src->pr_addr;
	dst->pr_size = src->pr_size;
	dst->pr_rssize = src->pr_rssize;

	dst->pr_ttydev = prexpldev(src->pr_ttydev);

	dst->pr_pctcpu = src->pr_pctcpu;
	dst->pr_pctmem = src->pr_pctmem;

	timestruc_32_to_n(&src->pr_start, &dst->pr_start);
	timestruc_32_to_n(&src->pr_time, &dst->pr_time);
	timestruc_32_to_n(&src->pr_ctime, &dst->pr_ctime);

	(void) memcpy(&dst->pr_fname[0], &src->pr_fname[0], PRFNSZ);
	(void) memcpy(&dst->pr_psargs[0], &src->pr_psargs[0], PRARGSZ);

	dst->pr_wstat = src->pr_wstat;
	dst->pr_argc = src->pr_argc;
	dst->pr_argv = src->pr_argv;
	dst->pr_envp = src->pr_envp;
	dst->pr_dmodel = src->pr_dmodel;

	lwpsinfo_32_to_n(&src->pr_lwp, &dst->pr_lwp);
}

#endif	/* _LP64 */

/*
 * Copyright (c) 1997-1999 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma	ident	"@(#)power.c 1.8	99/10/22 SMI"

/*
 *	Power Button Driver
 *
 *	This driver handles interrupt generated by the power button on
 *	platforms with "power" device node which has "button" property.
 *	Currently, these platforms are:
 *
 *		Ultra-5_10, Ultra-80
 *
 *	Only one instance is allowed to attach.  In order to know when
 *	an application that has opened the device is going away, a new
 *	minor clone is created for each open(9E) request.  There are
 *	allocations for creating minor clones between 1 and 255.  The ioctl
 *	interface is defined by pbio(7I) and approved as part of
 *	PSARC/1999/393 case.
 */

#include <sys/types.h>
#include <sys/conf.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#include <sys/ddi_impldefs.h>
#include <sys/cmn_err.h>
#include <sys/errno.h>
#include <sys/modctl.h>
#include <sys/machsystm.h>
#include <sys/open.h>
#include <sys/stat.h>
#include <sys/poll.h>
#include <sys/pbio.h>

/*
 * Maximum number of clone minors that is allowed.  This value
 * is defined relatively low to save memory.
 */
#define	POWER_MAX_CLONE	256

/*
 * Minor number is instance << 8 + clone minor from range 1-255; clone 0
 * is reserved for "original" minor.
 */
#define	POWER_MINOR_TO_CLONE(minor) ((minor) & (POWER_MAX_CLONE - 1))

/*
 * Driver global variables
 */
static void *power_state;
static int power_inst = -1;
static int power_button_enable = 1;

/*
 * Function prototypes
 */
static int power_attach(dev_info_t *, ddi_attach_cmd_t);
static int power_detach(dev_info_t *, ddi_detach_cmd_t);
static int power_getinfo(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int power_open(dev_t *, int, int, cred_t *);
static int power_close(dev_t, int, int, cred_t *);
static int power_ioctl(dev_t, int, intptr_t, int, cred_t *, int *);
static int power_chpoll(dev_t, short, int, short *, struct pollhead **);
static uint_t power_high_intr(caddr_t);
static uint_t power_soft_intr(caddr_t);
static void power_log_message(void);

/*
 * Structure used in the driver
 */
static struct power_soft_state {
	dev_info_t	*dip;		/* device info pointer */
	kmutex_t	power_mutex;	/* mutex lock */
	ddi_iblock_cookie_t soft_iblock_cookie; /* holds interrupt cookie */
	ddi_softintr_t	softintr_id;	/* soft interrupt id */
	uchar_t		clones[POWER_MAX_CLONE]; /* array of minor clones */
	int		monitor_on;	/* clone monitoring the button event */
					/* clone 0 indicates no one is */
					/* monitoring the button event */
	pollhead_t	pollhd;		/* poll head struct */
	int		events;		/* bit map of occured events */
	int		shutdown_pending; /* system shutdown in progress */
};

/*
 * Configuration data structures
 */
static struct cb_ops power_cb_ops = {
	power_open,		/* open */
	power_close,		/* close */
	nodev,			/* strategy */
	nodev,			/* print */
	nodev,			/* dump */
	nodev,			/* read */
	nodev,			/* write */
	power_ioctl,		/* ioctl */
	nodev,			/* devmap */
	nodev,			/* mmap */
	nodev,			/* segmap */
	power_chpoll,		/* poll */
	ddi_prop_op,		/* cb_prop_op */
	NULL,			/* streamtab */
	D_MP | D_NEW,		/* Driver compatibility flag */
	CB_REV,			/* rev */
	nodev,			/* cb_aread */
	nodev			/* cb_awrite */
};

static struct dev_ops power_ops = {
	DEVO_REV,		/* devo_rev, */
	0,			/* refcnt */
	power_getinfo,		/* getinfo */
	nulldev,		/* identify */
	nulldev,		/* probe */
	power_attach,		/* attach */
	power_detach,		/* detach */
	nodev,			/* reset */
	&power_cb_ops,		/* cb_ops */
	(struct bus_ops *)NULL,	/* bus_ops */
	NULL			/* power */
};

static struct modldrv modldrv = {
	&mod_driverops,		/* Type of module.  This one is a driver */
	"power button driver v1.8",	/* name of module */
	&power_ops,		/* driver ops */
};

static struct modlinkage modlinkage = {
	MODREV_1,
	(void *)&modldrv,
	NULL
};

/*
 * These are the module initialization routines.
 */

int
_init(void)
{
	int error;

	if ((error = ddi_soft_state_init(&power_state,
	    sizeof (struct power_soft_state), 0)) != 0)
		return (error);

	if ((error = mod_install(&modlinkage)) != 0)
		ddi_soft_state_fini(&power_state);

	return (error);
}

int
_fini(void)
{
	int error;

	if ((error = mod_remove(&modlinkage)) == 0)
		ddi_soft_state_fini(&power_state);

	return (error);
}

int
_info(struct modinfo *modinfop)
{
	return (mod_info(&modlinkage, modinfop));
}

/*ARGSUSED*/
static int
power_getinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
    void **result)
{
	struct power_soft_state *softsp;

	if (power_inst == -1)
		return (DDI_FAILURE);

	switch (infocmd) {
	case DDI_INFO_DEVT2DEVINFO:
		if ((softsp = ddi_get_soft_state(power_state, power_inst))
		    == NULL)
			return (DDI_FAILURE);
		*result = (void *)softsp->dip;
		return (DDI_SUCCESS);

	case DDI_INFO_DEVT2INSTANCE:
		*result = (void *)power_inst;
		return (DDI_SUCCESS);

	default:
		return (DDI_FAILURE);
	}
}

static int
power_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
	struct power_soft_state *softsp;

	switch (cmd) {
	case DDI_ATTACH:
		break;
	case DDI_RESUME:
		return (DDI_SUCCESS);
	default:
		return (DDI_FAILURE);
	}

	/*
	 * If the power node doesn't have "button" property, quietly
	 * fail to attach.
	 */
	if (ddi_prop_exists(DDI_DEV_T_ANY, dip, DDI_PROP_DONTPASS,
	    "button") == 0)
		return (DDI_FAILURE);

	if (power_inst != -1)
		return (DDI_FAILURE);

	power_inst = ddi_get_instance(dip);

	if (ddi_soft_state_zalloc(power_state, power_inst) != DDI_SUCCESS)
		return (DDI_FAILURE);

	if (ddi_create_minor_node(dip, "power_button", S_IFCHR,
	    (power_inst << 8) + 0, "ddi_power_button", 0) != DDI_SUCCESS)
		return (DDI_FAILURE);

	softsp = ddi_get_soft_state(power_state, power_inst);
	softsp->dip = dip;

	if (ddi_add_intr(dip, 0, NULL, NULL, power_high_intr,
	    (caddr_t)softsp) != DDI_SUCCESS) {
		cmn_err(CE_WARN, "power_attach: failed to add high-level "
		    " interrupt handler.");
		goto error;
	}

	if (ddi_get_soft_iblock_cookie(dip, DDI_SOFTINT_LOW,
	    &softsp->soft_iblock_cookie) != DDI_SUCCESS) {
		cmn_err(CE_WARN, "power_attach: ddi_get_soft_iblock_cookie "
		    "failed.");
		ddi_remove_intr(dip, 0, NULL);
		goto error;
	}

	mutex_init(&softsp->power_mutex, NULL, MUTEX_DRIVER,
	    (void *)softsp->soft_iblock_cookie);

	if (ddi_add_softintr(dip, DDI_SOFTINT_LOW, &softsp->softintr_id,
	    NULL, NULL, power_soft_intr, (caddr_t)softsp) != DDI_SUCCESS) {
		cmn_err(CE_WARN, "power_attach: failed to add soft "
		    "interrupt handler.");
		mutex_destroy(&softsp->power_mutex);
		ddi_remove_intr(dip, 0, NULL);
		goto error;
	}

	ddi_report_dev(dip);

	return (DDI_SUCCESS);

error:
	ddi_remove_minor_node(dip, "power_button");
	ddi_soft_state_free(power_state, power_inst);
	return (DDI_FAILURE);
}

/*ARGSUSED*/
/*
 * This driver doesn't detach.
 */
static int
power_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
	/*
	 * Since the "power" node has "reg" property, as part of
	 * the suspend operation, detach(9E) entry point is called.
	 * There is no state to save, since this register is used
	 * by OBP to power off the system and the state of the
	 * power off is preserved by hardware.
	 */
	return ((cmd == DDI_SUSPEND) ? DDI_SUCCESS :
	    DDI_FAILURE);
}

/*
 * Handler for the high-level interrupt.
 */
static uint_t
power_high_intr(caddr_t arg)
{
	struct power_soft_state *softsp = (struct power_soft_state *)arg;

	if (softsp->softintr_id != NULL)
		ddi_trigger_softintr(softsp->softintr_id);

	return (DDI_INTR_CLAIMED);
}

/*
 * Handler for the soft interrupt triggered by the high-level interrupt
 * handler.
 */
static uint_t
power_soft_intr(caddr_t arg)
{
	struct power_soft_state *softsp = (struct power_soft_state *)arg;

	if (!power_button_enable)
		return (DDI_INTR_CLAIMED);

	mutex_enter(&softsp->power_mutex);
	softsp->events |= PB_BUTTON_PRESS;
	if (softsp->monitor_on != 0) {
		mutex_exit(&softsp->power_mutex);
		pollwakeup(&softsp->pollhd, POLLRDNORM);
		pollwakeup(&softsp->pollhd, POLLIN);
		return (DDI_INTR_CLAIMED);
	}

	if (!softsp->shutdown_pending) {
		cmn_err(CE_WARN, "Power button is pressed, powering down "
		    "the system!");
		softsp->shutdown_pending = 1;
		do_shutdown();

		/*
		 * Wait a while for "do_shutdown()" to shut down the system
		 * before logging an error message.
		 */
		(void) timeout((void(*)(void *))power_log_message, NULL,
		    100 * hz);
	}
	mutex_exit(&softsp->power_mutex);

	return (DDI_INTR_CLAIMED);
}

/*
 * Open the device.
 */
/*ARGSUSED*/
static int
power_open(dev_t *devp, int openflags, int otyp, cred_t *credp)
{
	struct power_soft_state *softsp;
	int clone;

	if (otyp != OTYP_CHR)
		return (EINVAL);

	if ((softsp = ddi_get_soft_state(power_state, power_inst)) ==
	    NULL)
		return (ENXIO);

	mutex_enter(&softsp->power_mutex);
	for (clone = 1; clone < POWER_MAX_CLONE; clone++)
		if (!softsp->clones[clone])
			break;

	if (clone == POWER_MAX_CLONE) {
		cmn_err(CE_WARN, "power_open: No more allocation left "
		    "to create a clone minor.");
		mutex_exit(&softsp->power_mutex);
		return (ENXIO);
	}

	*devp = makedevice(getmajor(*devp), (power_inst << 8) + clone);
	softsp->clones[clone] = 1;
	mutex_exit(&softsp->power_mutex);

	return (0);
}

/*
 * Close the device.
 */
/*ARGSUSED*/
static  int
power_close(dev_t dev, int openflags, int otyp, cred_t *credp)
{
	struct power_soft_state *softsp;
	int clone;

	if (otyp != OTYP_CHR)
		return (EINVAL);

	if ((softsp = ddi_get_soft_state(power_state, power_inst)) ==
	    NULL)
		return (ENXIO);

	clone = POWER_MINOR_TO_CLONE(getminor(dev));
	mutex_enter(&softsp->power_mutex);
	if (softsp->monitor_on == clone)
		softsp->monitor_on = 0;
	softsp->clones[clone] = 0;
	mutex_exit(&softsp->power_mutex);

	return (0);
}

/*ARGSUSED*/
static  int
power_ioctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *cred_p,
    int *rval_p)
{
	struct power_soft_state *softsp;
	int clone;

	if ((softsp = ddi_get_soft_state(power_state, power_inst)) ==
	    NULL)
		return (ENXIO);

	clone = POWER_MINOR_TO_CLONE(getminor(dev));
	switch (cmd) {
	case PB_BEGIN_MONITOR:
		mutex_enter(&softsp->power_mutex);
		if (softsp->monitor_on) {
			mutex_exit(&softsp->power_mutex);
			return (EBUSY);
		}
		softsp->monitor_on = clone;
		mutex_exit(&softsp->power_mutex);
		return (0);

	case PB_END_MONITOR:
		mutex_enter(&softsp->power_mutex);

		/*
		 * If PB_END_MONITOR is called without first
		 * calling PB_BEGIN_MONITOR, an error will be
		 * returned.
		 */
		if (!softsp->monitor_on) {
			mutex_exit(&softsp->power_mutex);
			return (ENXIO);
		}

		/*
		 * This clone is not monitoring the button.
		 */
		if (softsp->monitor_on != clone) {
			mutex_exit(&softsp->power_mutex);
			return (EINVAL);
		}
		softsp->monitor_on = 0;
		mutex_exit(&softsp->power_mutex);
		return (0);

	case PB_GET_EVENTS:
		mutex_enter(&softsp->power_mutex);
		if (ddi_copyout((void *)&softsp->events, (void *)arg,
		    sizeof (int), mode) != 0) {
			mutex_exit(&softsp->power_mutex);
			return (EFAULT);
		}

		/*
		 * This ioctl returned the events detected since last
		 * call.  Note that any application can get the events
		 * and clear the event register.
		 */
		softsp->events = 0;
		mutex_exit(&softsp->power_mutex);
		return (0);

	/*
	 * This ioctl is used by the test suite.
	 */
	case PB_CREATE_BUTTON_EVENT:
		ddi_trigger_softintr(softsp->softintr_id);
		return (0);

	default:
		return (ENOTTY);
	}
}

/*ARGSUSED*/
static int
power_chpoll(dev_t dev, short events, int anyyet,
    short *reventsp, struct pollhead **phpp)
{
	struct power_soft_state *softsp;

	if ((softsp = ddi_get_soft_state(power_state, power_inst)) == NULL)
		return (ENXIO);

	mutex_enter(&softsp->power_mutex);
	*reventsp = 0;
	if (softsp->events)
		*reventsp = POLLRDNORM|POLLIN;
	else {
		if (!anyyet)
			*phpp = &softsp->pollhd;
	}
	mutex_exit(&softsp->power_mutex);

	return (0);
}

static void
power_log_message(void)
{
	struct power_soft_state *softsp;

	if ((softsp = ddi_get_soft_state(power_state, power_inst)) == NULL) {
		cmn_err(CE_WARN, "Failed to get internal state!");
		return;
	}

	mutex_enter(&softsp->power_mutex);
	softsp->shutdown_pending = 0;
	cmn_err(CE_WARN, "Failed to shut down the system!");
	mutex_exit(&softsp->power_mutex);
}

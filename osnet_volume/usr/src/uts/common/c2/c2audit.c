/*
 * Copyright (c) 1996-1999 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma ident	"@(#)c2audit.c	1.34	99/08/31 SMI"

/*
 * These routines are responsible for constructing the
 * downloadable module to perform auditing and device
 * allocating.
 *
 * This file normally contains the interface routines between the kernel and
 * the actual code that performs the auditing.
 *
 * Only stubs to those functions are included in the base os.
 */

#include <sys/types.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/cred.h>
#include <sys/stropts.h>
#include <sys/systm.h>
#include <sys/pathname.h>
#include <sys/exec.h>
#include <sys/thread.h>

/*
 * This is the loadable module wrapper.
 */

#include <sys/modctl.h>
#include "sys/syscall.h"

extern void auditsys(struct auditcalls *, rval_t *);
extern void printf(const char *, ...);

static struct sysent auditsysent = {
	6,
	0,
	auditsys
};

struct auditcalls {
	long	code;
	long	a1;
	long	a2;
	long	a3;
	long	a4;
	long	a5;
};

/*
 * Module linkage information for the kernel.
 */
extern struct mod_ops mod_syscallops;


static struct modlsys modlsys = {
	&mod_syscallops, "C2 audit call", &auditsysent
};

static struct modlinkage modlinkage = {
	MODREV_1, (void *)&modlsys, 0
};

int
_init()
{
	return (mod_install(&modlinkage));
}

int
_fini()
{
	return (mod_remove(&modlinkage));
}

int
_info(modinfop)
	struct modinfo *modinfop;
{
	return (mod_info(&modlinkage, modinfop));
}

void
auditsys(uap, rvp)
	struct auditcalls *uap;
	rval_t *rvp;
{
	printf("audit_sys code %d...\n", uap->code);
}

void
audit_init()
{
}

void
audit_free()
{
}

/*
 * ----------------------------------------------------------------------
 * This hook must be in the (to be added) mutex in lookuppn() about the
 * pn_peekchar "if" statement so that the cwd/root names are correct when
 * used to anchor the path names.
 * ----------------------------------------------------------------------
 */
/*
 * Enter system call. Do any necessary setup here. allocate resouces, etc.
 */
void
audit_start(
	unsigned type,
	unsigned scid,
	int error,
	klwp_t *lwp)
{
}

/*
 * system call has completed. Now determine if we genearate an audit record
 * or not.
 */
void
audit_finish(
	unsigned type,
	unsigned scid,
	int error,
	rval_t *rval)
{
}


/*
 * record if suser is called and if it succeeds or fails.
 */
void
audit_suser(int flg)
{
}

/*
 * newproc() audit stub. Duplicate any information associated with proc struct.
 */
void
audit_newproc(proc_t *pid)
{
}

/*
 * free proc audit_data space
 */
void
audit_pfree(proc_t *pid)
{
}

/*
 * clear flags that cause audit record generation. This is mainly used in
 * fork where we return twice. We only want a record generated by the
 * parent process and not the child.
 */
void
audit_clear(proc_t *pid)
{
}

/* not needed, part of audit_finish for chdir system call */
void
audit_chdir(int v)
{
}

/* not needed, part of audit_finish for fchdir system call */
void
audit_fchdir(file_t *fd, int v)
{
}

/* not needed, part of audit_finish for chroot system call */
void
audit_chroot(int v)
{
}

/* not needed, part of audit_finish for fchroot system call */
void
audit_fchroot(file_t *fd, int v)
{
}

void
audit_falloc(file_t *fd)
{
}

void
audit_unfalloc(file_t *fd)
{
}

/*
 * update pwd/root for current process.
 */
void
audit_chdirec(vnode_t *vp, vnode_t **vpp)
{
}

void
audit_getf(int fd)
{
}

void
audit_closef(file_t *fd)
{
}

void
audit_core_start(int sig)
{
}

void
audit_core_finish(int f)
{
}

void
audit_stropen(
	struct vnode *vp,
	dev_t *devp,
	int flag,
	cred_t *crp)
{
}

void
audit_strclose(
	struct vnode *vp,
	int flag,
	cred_t *crp)
{
}

void
audit_strioctl(
	struct vnode *vp,
	int cmd,
	intptr_t arg,
	int flag,
	int copyflag,
	cred_t *crp,
	int *rvalp)
{
}

void
audit_strputmsg(
	struct vnode  *vp,
	struct strbuf *mctl,
	struct strbuf *mdata,
	unsigned char  pri,
	int flag,
	int fmode)
{
}

struct fcntla {
	long fdes;
	long cmd;
	long arg;
};

int
audit_c2_revoke(struct fcntla *uap, rval_t *rvp)
{
	return (0);
}

/*
 * We have reached the end of a path in fs/lookup.c . We get three pieces of
 * information here: the path (pnp), the vnode of the last component (vp), and
 * the status of the last access (f).
 */
void
audit_savepath(
	struct pathname *pnp,
	vnode_t *vp,
	int error)
{
}

/*
 * starting path search in lookup.
 */
void
audit_anchorpath(struct pathname *pnp, int flag)
{
}

/*
 * Error condition where next component was in error (append to path anyway)
 */
void
audit_addcomponent(struct pathname *pnp)
{
}

void
audit_symlink(struct pathname *pnp, struct pathname *linkpath_p)
{
}

void
audit_exit(void)
{
}

void
audit_exec(const char *argstr, const char *envstr, ssize_t argc, ssize_t envc)
{
}

void
audit_vncreate_start()
{
}

void
audit_vncreate_finish(struct vnode *vp, int error)
{
}

void
audit_enterprom(int flag)
{
}

void
audit_exitprom(flag)
int flag;
{
}

void
audit_thread_create(t, state)
	kthread_id_t t;
	int state;
{
}

void
audit_thread_free(t)
	kthread_id_t t;
{
}

void
audit_copen(int fd, file_t *fp, vnode_t	*vp)
{
}

void
audit_setf(file_t *fp, int fd)
{
}

void
audit_strgetmsg(
	struct vnode  *vp,
	struct strbuf *mctl,
	struct strbuf *mdata,
	unsigned char  *pri,
	int *flag,
	int fmode)
{
}

void
audit_sock(
	int type,	/* type of tihdr.h header requests */
	queue_t *q,	/* contains the process and thread audit data */
	mblk_t *mp,	/* contains the tihdr.h header structures */
	int from)	/* timod or sockmod request */
{
}

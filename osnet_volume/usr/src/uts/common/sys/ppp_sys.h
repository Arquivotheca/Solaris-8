/*
 * Copyright (c) 1992,1997-1998 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#ifndef _SYS_PPP_SYS_H
#define	_SYS_PPP_SYS_H

#pragma ident	"@(#)ppp_sys.h	1.24	98/06/11 SMI"

#include <netinet/in.h>

#ifdef	__cplusplus
extern "C" {
#endif

#define	PPP_VERSION	(1)

#define	CONV_OPT(VALUE, MACHP, OPNUM) (VALUE == OLD_ALLOW ? \
	MACHP -> standard_allow[OPNUM] : (VALUE == OLD_DISALLOW ? \
	DISALLOW_BOTH : VALUE))
/*
 * PPP LCP/NCP events
 */
typedef enum { Up, Down, Open, Close, Togt0, Toeq0, Rcrgood, Rcrbad, Rca,
		Rcn, Rtr, Rta, Ruc, Rxjgood, Rxjbad, Rxr }
	pppEvent_t;

#define	NullEvent	(-1)

typedef enum { NullAct, Tld, Tlu, Tls, Tlf, Irc, Zrc, Scr, Sca, Scn,
		Str, Sta, Scj, Ser, Ircscr, Ircscrsca, Ircstr,
		Ircscrscn, Scatlu, Irctlu, Tldircstr, Tldscrsca,
		Tldscrscn, Tldzrcsta, Tldscr, Tldscjscr,
		Mcrsca, Mcrscn, Circscr } pppAction_t;

typedef enum { PPPIN_OPEN = 0x500, PPPIN_CLOSE, PPPIN_UP, PPPIN_DOWN,
		PPPIN_AUTH_LOC, PPPIN_AUTH_REM, PPPIN_AUTH_BOTH,
		PPPIN_TIMEOUT1, PPPIN_TIMEOUT2, PPPIN_FORCE_REM,
		PPPIN_AUTHOK, PPPIN_AUTHNOK }
		internal_events;

#define	CROSS_HI	1
#define	CROSS_LO	0

/*
 * Note: ppp_ioctl.h defines a pppState enumeration with verbose names
 */
typedef enum { S0 = 0, S1, S2, S3, S4, S5, S6, S7, S8, S9 }
	pppState_t;

#define	REQ_SENT_STATE_PPP(state) \
	((state) == S6 /* Req-sent */ || \
	(state) == S7 /* Ack-Rcvd */ || \
	(state) == S8 /* Ack-Sent */)


#define	MD5	5
/*
 * PPP finite state machine defines
 *
 * PPP state defines - these are encoded in the lower byte of a
 * PPP finite state machine entry
 */
#define	PPP_NSTATES	(10)
#define	PPP_NACTIONS	(26)
#define	PPP_NEVENTS	(16)	/* not counting the error events */

/*
 * PPP action defines - these are encoded in the upper byte of a
 * PPP finite state machine entry
 */
#define	TLD		(Tld << 8)
#define	TLU		(Tlu << 8)
#define	TLS		(Tls << 8)
#define	TLF		(Tlf << 8)
#define	IRC		(Irc << 8)
#define	ZRC		(Zrc << 8)
#define	SCR		(Scr << 8)
#define	SCA		(Sca << 8)
#define	SCN		(Scn << 8)
#define	STQ		(Str << 8)
#define	STA		(Sta << 8)
#define	SCJ		(Scj << 8)
#define	SER		(Ser << 8)
#define	IRCSCR		(Ircscr << 8)
#define	IRCSCRSCA	(Ircscrsca << 8)
#define	IRCSCRSCN	(Ircscrscn << 8)
#define	IRCSTR		(Ircstr << 8)
#define	SCATLU		(Scatlu << 8)
#define	IRCTLU		(Irctlu << 8)
#define	TLDIRCSTR	(Tldircstr << 8)
#define	TLDSCRSCA	(Tldscrsca << 8)
#define	TLDSCRSCN	(Tldscrscn << 8)
#define	TLDZRCSTA	(Tldzrcsta << 8)
#define	TLDSCR		(Tldscr << 8)
#define	TLDSCJSCR	(Tldscjscr << 8)
#define	TLDIRCSTR	(Tldircstr << 8)
#define	MCRSCA		(Mcrsca << 8)
#define	MCRSCN		(Mcrscn << 8)
#define	CIRCSCR		(Circscr << 8)


#define	FSM_ERR (-1)

typedef short			pppTuple_t;
typedef struct ppp_option	pppOption_t;


/*
 * PPP frame-level definitions
 *
 * Format of a PPP frame [RFC1171 page 5]
 *
 *    | flag | address | control | protocol | data | FCS | flags
 *
 *	0x7e	0xff	0x03	0x????	*	0x????	0x7e
 *
 *		< --------  user supplied ------------ >
 *
 * (remainder generated by the HDLC controller on the ISDN card)
 */
struct ppp_frame_hdr {
	uchar_t	addr;
	uchar_t	ctrl;
	ushort_t prot;
};

#define	PPP_FR_HDRSZ		(sizeof (struct ppp_frame_hdr))
#define	PPP_FRAME_ADDR		(0xff)
#define	PPP_FRAME_CTRL		(0x03)
#define	PPP_MAX_CP_FRAMESZ	(1500)
#define	PPP_ESCAPE		(0x7d)
#define	PPP_FLAG		(0x7e)
#define	PPP_MASK		(0x20)

/*
 * PPP packet-level definitions
 *
 * Format of a PPP packet (the data field above) [RFC1171 page 21]
 *
 * | Code |  Id	 |  Length |
 *
 */
struct ppp_pkt_hdr {
	uchar_t	code;
	uchar_t	id;
	ushort_t length;
};

#define	PPP_PKT_HDRSZ		(sizeof (struct ppp_pkt_hdr))

struct ppp_hdr {
	struct ppp_frame_hdr	fr;
	struct ppp_pkt_hdr	pkt;
};

#define	PPP_HDRSZ	(PPP_FR_HDRSZ+PPP_PKT_HDRSZ)

/*
 * PPP link control protocol, the IP control protocol is a subset
 * of this (no EchoReq/Rep or DiscardReq).   This is the "code"
 * field above
 */
enum ppp_cp { ConfigureReq = 1, ConfigureAck, ConfigureNak, ConfigureRej,
		TerminateReq, TerminateAck, CodeRej, ProtoRej, EchoReq,
		EchoRep, DiscardReq };

/*
 * PPP option definitions
 *
 * negotiable options for link/network control protocols
 *
 * Options are encoded in the form of [type][length][data]
 * triplets [RFC1172]
 */

/*
 * this is the maximum size of a LCP/NCP option (in bytes)
 */
#define	PPP_MAX_OPTSZ	(256)

/*
 * define one option
 */
struct ppp_option {
	uchar_t		type;
	uchar_t		length;
	uchar_t		data[PPP_MAX_OPTSZ];
	int		(*negotiate)();
	uchar_t		flags;
	pppOption_t	*next;	/* to next option of this type */

};

/* Option flags */
#define	DO_NAK	1

struct ppp_opthdr {
	uchar_t		type;
	uchar_t		length;
};

typedef	 struct {
	ushort_t proto;
	uchar_t	max_slot;
	uchar_t	cslot;
} vj_op_t;


typedef struct {
	ushort_t	proto;
	uint_t		rep_period;
} lqm_op_t;

struct ex_proto_event {
	uint_t		event;
	pppProtocol_t	protocol;
};

struct lqmstruct_t {
	uint_t		out_rep_period;
	uint_t		in_rep_period;
};

typedef struct {
	ipaddr_t source;
	ipaddr_t dest;
} addr_pair_t;

typedef struct {
	ushort_t prot;
	uchar_t algorithm;
} chap_op_t;


typedef ipaddr_t address_t;

typedef struct ex_proto_event ExProtoEvent_t;

/*
 * option negotiation results
 */
#define	OPT_OK		(0)	/* option is acceptable */
#define	OPT_NOK		(1)	/* option is unacceptable */
#define	OPT_NEW		(2)	/* new value for option proposed */
#define	OPT_FATAL	(3)	/* fatal option for negotiation */
#define	OPT_ABSENT	(4)
#define	OPT_IGNORE	(5)	/* Cause a packet to be ignored */
#define	OPT_LOOP	(6)	/* Cause a packet to be ignored */


struct mib_struct {
	uint_t	ifOutUniPackets;
	uint_t	ifOutNUniPackets;
	uint_t	ifOutOctets;
	uint_t	ifInUniPackets;
	uint_t	ifInNUniPackets;
	uint_t	ifInDiscards;
	uint_t	ifInErrors;
	uint_t	ifInOctets;
};

/*
 * options for the link control protocol...
 */
enum lcp_opt { MaxReceiveUnit = 1, AsyncControlMap, AuthenticationType,
		LinkQualityMon, MagicNumber, NotDefined, ProtoFieldCompress,
		AddrCtrlCompress };

#define	PPP_MAX_LCP_OPTS (AddrCtrlCompress)

/*
 * initial configuration options for LCP...
 */
#define	PPP_DEF_MRU	    (1500)	 /* default maximum receive unit  */
#define	PPP_MAX_MRU	    (3000)	 /* maximum mru value		  */
#define	PPP_MIN_MRU	    (60)	 /* minimum mru value		  */

#define	HI_OF(x)	    ((x) >> 8)	 /* return high byte of short x */
#define	LO_OF(x)	    ((x) & 0xff) /* return low byte of short x */

#define	PPP_DEF_ASCM	    (0xffffffff) /* async control character map	  */
#define	PPP_DEF_MAX_LOOP  (5)
#define	PPP_DEF_NOFLAG	  (1000)

/*
 * options for the IP network control protocol...
 */
enum ipncp_opt { IPAddr = 1, IPCompType, IPAddrNew };

#define	PPP_MAX_IPNCP_OPTS (IPAddrNew)

/*
 * maximum opts needed
 */
#define	PPP_MAX_OPTS	(256)

/*
 * IP protocol compression values
 */
#define	VJCOMP		(0x002d)
#define	VJCOMP_OLD	(0x0037)

/*
 * PPP timer and counter defines
 *
 * Initial PPP timer and counter values, may be adjusted
 * [RFC1171 Page 20]
 */
#define	PPP_DEF_RESTIMER    (3000)	/* restart timer interval (millisecs) */
#define	PPP_DEF_MAXRESTART  (10)	/* maximum number of restarts	 */
#define	PPP_DEF_MAXLOOPRESTART	(5)	/* max number of looped restarts */


typedef struct ppp_link pppLink_t;

typedef struct chapMachine chapMachine_t;
typedef struct papMachine papMachine_t;
typedef struct lqmMachine lqmMachine_t;

/*
 * PPP finite state machine user defines
 */
typedef struct {

/*
 * management variables
 */
	queue_t		*readq;		/* pointer to read queue */

	pppProtocol_t	protocol;	/* control protocol in use */

	pppProtocol_t	ntype;		/* network type in use */

	pppState_t	state;		/* current LCP/NCP state */
	pppState_t	laststate;	/* last LCP/NCP state */
	pppLink_t	*linkp;		/* ptr to parent link */

	uchar_t		crid;		/* current conf.req frame identifier */

	timeout_id_t	restart;	/* restart timer identifier */
	timeout_id_t	timedoutid;

	int		restart_counter;
	int		loopback_counter;

	mblk_t		*crp;		/* ptr to last sent conf.req packet */
	mblk_t		*crp_opts;	/* ptr to opts of last conf.req */

	mblk_t		*pkt;		/* ptr to last received cp packet */

/*
 * negotiable options
 */
	int		allowneg[PPP_MAX_OPTS+1];
	int		standard_allow[PPP_MAX_OPTS+1];
	pppOption_t	*outbound[PPP_MAX_OPTS+1];	/* outbound optionss */
	pppOption_t	*inbound[PPP_MAX_OPTS+1];	/* inbound options */
	pppOption_t	**imp;			/* implemented options */
	uint_t		optsz;			/* # of elements valid */

/*
 * control protocol statistics
 */
	pppCPEntry_t	stats;		/* control protocol stats */

/*
 * network protocol statistics - IP only for the moment
 */
	pppIPEntry_t	ip;		/* ip stats */

	uint_t		attempts;
	uint_t		max_attempts;
	uint_t		rsts;
	int		starting;
	int		conf_nak_counter;
} pppMachine_t;


/*
 * packet input buffer for aggregating /FCS'ing /unstuffing Async frames
 */
struct pib {
	mblk_t *mblk;
	int	 bufsize;
	unsigned char	 escaped;  /* have we seen an escape char */
	unsigned char	 flush;	   /* deal with over & underruns */
	unsigned short fcs;	   /* FCS on this packet so far */
	mblk_t *resid;

/*
 * data from next PPP frame that was in a message that had the Frame
 * character
 */
};

/*
 * message used to manage ppp protocol timeouts
 */
typedef struct {

	int		magic;
	pppMachine_t	*machp;

} pppTimeoutInd_t;

#define	PPP_TIMEOUT_MAGIC	(0x25081963)

#define	MAX_NEG_ATTEMPTS (25)

/*
 * PPP datalink defines
 *
 * Details of one PPP datalink
 * This is composed of one state machine for the link control protocol,
 * and then state machine entry(s) for the network layer protocols.
 * For Phase 1 PPP with only IP supported there is one static entry
 * corresponding to IP NCP.   This will not be the case in multiprotocol PPP
 */

typedef struct {
	ushort_t	pppLinkControlIndex;		/* 0 => this link */
	uchar_t		pppLinkCRCSize;			/* not used */
	uchar_t		pppLinkMaxRestarts;
	uint_t		pppLinkRestartTimerValue;	/* millisecs */
	int		pppLinkRecvProtoComp;
	int		pppLinkRecvAddrComp;
	int		pppLinkSendProtoComp;
	int		pppLinkSendAddrComp;
	ushort_t	pppLinkLocalMRU;		/* bytes */
	ushort_t	pppLinkRemoteMRU;		/* bytes */
	uint_t		pppLinkMediaType;		/* Async/Sync */
	uint_t		pppLinkVersion;			/* RFC1171/RFC1331 */
	uint_t		pppLinkREQMagicNumber;
	uint_t		pppLinkNAKMagicNumber;
	uint_t		pppLinkLocalMagicNumber;
	uint_t		pppLinkRemoteMagicNumber;
	int		pppLinkCommand;
	ipaddr_t	pppIPLocalAddr;			/* for IP addr neg */
	ipaddr_t	pppIPRemoteAddr;
	int		pppIPcompSend;			/* e.g. VJ header */
	int		pppIPcompRecv;			/* e.g. VJ header */
	uint_t		pppLinkLocalACCMap;		/* not used */
	uint_t		pppLinkRemoteACCMap;		/* not used */
#if defined(_LP64) || defined(_I32LPx)
	clock32_t	pppLinkLastFlagTime;
	clock32_t	pppLinkMaxNoFlagTime;
#else
	clock_t		pppLinkLastFlagTime;
	clock_t		pppLinkMaxNoFlagTime;
#endif
	int		pppRemAuthok;
	int		pppLocAuthok;
	int		pppLinkOutLQM;
	int		pppLinkInLQM;
	int		pppLinkMaxLoopCount;
	int		pppLinkLoopCount;
} pppLinkConf_t;

typedef struct {
	ushort_t	pppLinkControlIndex;		/* 0 => this link */
	uchar_t		pppLinkCRCSize;			/* not used */
	uchar_t		pppLinkMaxRestarts;
	ushort_t	pppLinkLocalMRU;		/* bytes */
	ushort_t	pppLinkRemoteMRU;		/* bytes */
	uint_t		pppLinkRestartTimerValue;	/* millisecs */
	uint_t		pppLinkLocalACCMap;		/* not used */
	uint_t		pppLinkMagicLoopCount;		/* not used */
	uint_t		pppLinkMediaType;		/* Async/Sync */
	uint_t		pppLinkVersion;			/* RFC1171/RFC1331 */
	int		pppLinkCommand;
	int		pppIPcompression;		/* e.g. VJ header */
	int		pppLinkAddrProtoComp;		/* addr/prot comp */
	ipaddr_t	pppIPLocalAddr;			/* for IP addr neg. */
	ipaddr_t	pppIPRemoteAddr;
} pppIsdnLinkControlEntry_t;

/*
 * PAP password structure [RFC1172 page 27]
 */
typedef struct {
	uchar_t		papPeerIdLen;
	uchar_t		papPeerId[PPP_MAX_PASSWD];
	uchar_t		papPasswdLen;
	uchar_t		papPasswd[PPP_MAX_PASSWD];
} pppIsdnPAP_t;

struct ppp_link {

	int				link_up;
/*
 * LCP state machine, one of these per datalink
 */
	pppMachine_t			*lcp;

/*
 * Network control protocol state machine.  For the moment
 * this is only IP NCP
 */

	pppMachine_t			*ncp;

/*
 * per-link mutex
 */

	int				device_is_up;

	queue_t				*readq;

	chapMachine_t			*chap;

	papMachine_t			*pap;
/*
 * per-link mutex
 */
	lqmMachine_t			*lqm;

	vjstruct_t			vjstruct;

	struct lqmstruct_t		lqmstruct;

	struct mib_struct		mib_data;
#ifndef _SunOS4
	kmutex_t			lplock;
#endif

	pppLinkConf_t			conf;

/*
 * Link control information, such as mru and mtu
 */
	pppLinkControlEntry_t		ctrl;

/*
 * Link status information, such as current state
 */
	pppLinkStatusEntry_t		state;

/*
 * Link error information
 */
	pppLinkErrorsEntry_t		errs;

/*
 * Authentication control information
 */
	pppAuthControlEntry_t		auth;
	uchar_t				authstate;
	uchar_t				authin;
	uchar_t				authout;
	mblk_t				*authreq;
	mblk_t				*authres;
	mblk_t				*passwd;
	mblk_t				*out_message;
	mblk_t				*in_message;

/*
 * Memory allocation failures outstanding
 */
	timeout_id_t			memouts;

/*
 * These variables have to do with gathering up
 * Async packets which may show up in several messages.
 *
 */
	struct pib			pib;   /* packet input buffer */

	uint_t				outLQM;
	uint_t				inLQM;

	uint_t				remauth;
	uint_t				locauth;
	uint_t				remauthok;
	uint_t				locauthok;
	uint_t				looped_back;

};

/*
 * PPP MIB defines
 */
#define	PPP_MAX_MIB	(16)	/* maximum MIB size */

/*
 * externs
 *
 * declarations for variables and functions external to this
 * module
 */
extern int		ppp_debug;
extern int		hz;



#ifndef _SunOS4
extern timestruc_t	hrestime;
#endif

/*
 * Miscellaneous defines...
 */

/*
 * when the PPP module runs out of memory, it will defer its memory
 * requests for PPP_MEMRETRY ticks, and then retry.
 */
#define	PPP_MEMRETRY		(3*hz)
#define	QUEUE_MEM_RETRY(q, mp)	(void) putbq(q, mp); \
				queue_memory_retry(q)


#ifndef TRUE
#define	TRUE (1)
#endif

#ifndef FALSE
#define	FALSE (0)
#endif

#define	MTYPE(mp)	(mp->b_datap->db_type)
#define	ISPULLEDUP(mp)  (((mp)->b_wptr - (mp)->b_rptr == msgdsize(mp)) && \
			((intptr_t) (mp)->b_rptr % sizeof (intptr_t) == 0) \
			? 1 : 0)



/*
 * debugging defines
 */
#define	PPP_STREAMS	(1)
#define	PPP_TIMERS	(2)
#define	PPP_MEMORY	(4)
#define	PPP_STATE	(8)
#define	PPP_ERRORS	(16)
#define	PPP_OPTIONS	(32)
#define	PPP_FRAMES	(64)
#define	PPP_API		(128)

/*
 * Some PPP's don't count the CRC or header in the MRU size...
 */
#define	HDR_SLOP    (16)

#define	PPP_MINBUF(lp) (((lp->conf.pppLinkRemoteMRU) > PPP_DEF_MRU) ? \
	    (lp->conf.pppLinkRemoteMRU + HDR_SLOP) : \
	    (PPP_DEF_MRU + HDR_SLOP))

#ifdef PPP_DEBUG

#define	PPP_FRAME_DUMP(X, Y) (frame_dump(X, Y))

#ifdef _SunOS4

/*
 * Log STREAMS debug messages
 */
#define	PPP_MID		0
#define	PPP_SID		0

#define	PPP_STRDB0(s)		if (ppp_debug & PPP_STREAMS) \
		printf(s)
#define	PPP_STRDBG(s, t)	if (ppp_debug & PPP_STREAMS) \
					log(LOG_DEBUG, s, t)
#define	PPP_STRDBG2(s, t, u)	if (ppp_debug & PPP_STREAMS) \
					log(LOG_DEBUG, s, t, u)
#define	PPP_STRDBG4(s, t, u, v, w)    if (ppp_debug & PPP_STREAMS) \
					log(LOG_DEBUG, s, t, u, v, w)

/*
 * Log timer debug messages
 */
#define	PPP_TIMDBG(s, t)	if (ppp_debug & PPP_TIMERS) \
					log(LOG_DEBUG, s, t)

/*
 * Log memory debug messages
 */
#define	PPP_MEMDBG(s, t)	if (ppp_debug & PPP_MEMORY) \
					log(LOG_DEBUG, s, t)
#define	PPP_MEMDBG2(s, t, u)	if (ppp_debug & PPP_MEMORY) \
					log(LOG_DEBUG, s, t, u)

/*
 * Log finite state machine debug messages
 */
#define	PPP_FSMDBG0(s)		if (ppp_debug & PPP_STATE) \
					log(LOG_DEBUG, s)
#define	PPP_FSMDBG(s, t)	if (ppp_debug & PPP_STATE) \
					log(LOG_DEBUG, s, t)
#define	PPP_FSMDBG2(s, t, u)	if (ppp_debug & PPP_STATE) \
					log(LOG_DEBUG, s, t, u)
#define	PPP_FSMDBG4(s, t, q, u, v)   if (ppp_debug & PPP_STATE) \
					log(LOG_DEBUG, s, t, q, u, v)
#define	PPP_FSMDBG5(s, t, q, u, v, w)	if (ppp_debug & PPP_STATE) \
					log(LOG_DEBUG, s, t, q, u, v, w)

/*
 * Log error messages
 */
#define	PPP_ERROR(s, t)		if (ppp_debug & PPP_ERRORS) \
					log(LOG_DEBUG, s, t)

/*
 * Log option processing messages
 */
#define	PPP_OPTDBG(s, t)	if (ppp_debug & PPP_OPTIONS) \
					log(LOG_DEBUG, s, t)
#define	PPP_OPTDBG2(s, t, u)	if (ppp_debug & PPP_OPTIONS) \
					log(LOG_DEBUG, s, t, u)
#define	PPP_OPTDBG3(s, t, u, v) if (ppp_debug & PPP_OPTIONS) \
					log(LOG_DEBUG, s, t, u, v)

/*
 * Log API messages
 */
#define	PPP_APIDBG2(s, t, u)		if (ppp_debug & PPP_API) \
					log(LOG_DEBUG, s, t, u)

#define	PPP_APIDBG(s, t)	if (ppp_debug & PPP_API) \
					log(LOG_DEBUG, s, t)

#else	/* _SunOS4 (therefore SunOS 5.x follows) */

/*
 * Log STREAMS debug messages
 */
#define	PPP_MID		0
#define	PPP_SID		0

#define	PPP_STRDBG(s, t)	if (ppp_debug & PPP_STREAMS) \
		printf(s, t)
#define	PPP_STRDBG2(s, t, u)	if (ppp_debug & PPP_STREAMS) \
		printf(s, t, u)
#define	PPP_STRDBG4(s, t, u, v, w)    if (ppp_debug & PPP_STREAMS) \
		printf(s, t, u, v, w)

/*
 * Log timer debug messages
 */
#define	PPP_TIMDBG(s, t)	if (ppp_debug & PPP_TIMERS) \
		printf(s, t)

/*
 * Log memory debug messages
 */
#define	PPP_MEMDBG(s, t)	if (ppp_debug & PPP_MEMORY) \
		printf(s, t)
#define	PPP_MEMDBG2(s, t, u)	if (ppp_debug & PPP_MEMORY) \
		printf(s, t, u)

/*
 * Log finite state machine debug messages
 */
#define	PPP_FSMDBG0(s)		if (ppp_debug & PPP_STATE) \
		printf(s)
#define	PPP_FSMDBG(s, t)	if (ppp_debug & PPP_STATE) \
		printf(s, t)
#define	PPP_FSMDBG2(s, t, u)	if (ppp_debug & PPP_STATE) \
		printf(s, t, u)
#define	PPP_FSMDBG4(s, t, q, u, v)   if (ppp_debug & PPP_STATE) \
		printf(s, t, q, u, v)
#define	PPP_FSMDBG5(s, t, q, u, v, w)	if (ppp_debug & PPP_STATE) \
		printf(s, t, q, u, v, w)

/*
 * Log error messages
 */
#define	PPP_ERROR(s, t)		if (ppp_debug & PPP_ERRORS) \
		printf(s, t)

/*
 * Log option processing messages
 */
#define	PPP_OPTDBG(s, t)	if (ppp_debug & PPP_OPTIONS) \
		printf(s, t)
#define	PPP_OPTDBG2(s, t, u)	if (ppp_debug & PPP_OPTIONS) \
		printf(s, t, u)
#define	PPP_OPTDBG3(s, t, u, v) if (ppp_debug & PPP_OPTIONS) \
		printf(s, t, u, v)

/*
 * Log API messages
 */
#define	PPP_APIDBG2(s, t, u)		if (ppp_debug & PPP_API) \
					printf(s, t, u)

#define	PPP_APIDBG(s, t)	if (ppp_debug & PPP_API) \
					printf(s, t)

#endif /* _SunOS4 */

#else /* !PPP_DEBUG */

#define	PPP_STRDB0(s)
#define	PPP_STRDBG(s, t)
#define	PPP_STRDBG2(s, t, u)
#define	PPP_STRDBG4(s, t, u, v, w)
#define	PPP_TIMDBG(s, t)
#define	PPP_MEMDBG(s, t)
#define	PPP_MEMDBG2(s, t, u)
#define	PPP_FSMDBG0(s)
#define	PPP_FSMDBG(s, t)
#define	PPP_FSMDBG2(s, t, u)
#define	PPP_FSMDBG5(s, t, u, v, w, x)
#define	PPP_ERROR(s, t)
#define	PPP_OPTDBG(s, t)
#define	PPP_OPTDBG2(s, t, u)
#define	PPP_OPTDBG3(s, t, u, v)
#define	PPP_APIDBG(s, t)
#define	PPP_APIDBG2(s, t, u)
#define	PPP_FRAME_DUMP(X, Y)

#endif

#ifdef	__cplusplus
}
#endif

#endif	/* _SYS_PPP_SYS_H */

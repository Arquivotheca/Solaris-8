/*
 * Copyright (c) 1992-1998 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma ident	"@(#)ppp_lqm.c	1.11	98/06/11 SMI"

/*
 * A STREAMS implementation of the link quality monitoring protocol
 * described in RFC1333
 */


#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/stropts.h>
#include <sys/ddi.h>
#include <sys/debug.h>
#include <sys/time.h>
#include <sys/syslog.h>
#include <sys/strlog.h>
#include <sys/kmem.h>
#include <sys/mutex.h>
#include <sys/t_lock.h>
#include <sys/strsun.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>

#include <netinet/ip.h>
#include <netinet/tcp.h>

#ifdef ISERE_TREE
#include <ppp/vjcomp.h>
#include <ppp/ppp_ioctl.h>
#include <ppp/ppp_sys.h>
#include <ppp/ppp_lqm.h>
#include <ppp/ppp_extern.h>
#else
#include <sys/vjcomp.h>
#include <sys/ppp_ioctl.h>
#include <sys/ppp_sys.h>
#include <sys/ppp_lqm.h>
#include <sys/ppp_extern.h>
#endif

static void send_lqm_report(lqmMachine_t *machp);
static void cancel_lqm_timer(lqmMachine_t *machp);
static void start_lqm_timer(lqmMachine_t *machp);
static void lqm_timeout(void *);
static LQM_pack_t ntoh_LQM_pack_t(LQM_pack_t);
static LQM_pack_t hton_LQM_pack_t(LQM_pack_t);


/*
 * lqm_external_event()
 *
 * Process an event generated by other layers or the link manager.
 */
void
lqm_external_event(pppLink_t *lp, uint_t exevent)
{
	lqmMachine_t	*machp;

	switch (exevent) {
	case PPPIN_UP:
		send_lqm_report(lp->lqm);
		start_lqm_timer(lp->lqm);
		break;
	case PPPIN_DOWN:
		cancel_lqm_timer(lp->lqm);
		break;
	case PPPIN_TIMEOUT1:
		machp = lp->lqm;
		if (machp->timedoutid != machp->lqm_send)
			return;
		machp->lqm_send = 0;
		send_lqm_report(machp);
		start_lqm_timer(machp);
		break;
	}
}


/*
 * cancel_lqm_timer()
 *
 * Cancel the link quality monitor timer.
 */
static void
cancel_lqm_timer(lqmMachine_t *machp)
{
	if (machp->lqm_send == 0) {
		return;
	}

	(void) untimeout(machp->lqm_send);
	machp->lqm_send = 0;
}


/*
 * start_lqm_timer()
 *
 * Start link quality timer
 */
static void
start_lqm_timer(lqmMachine_t *machp)
{
	cancel_lqm_timer(machp);
	machp->lqm_send = timeout(lqm_timeout, machp,
	    MSEC_TO_TICK(machp->linkp->lqmstruct.out_rep_period * 10));
}


/*
 * lqm_timeout()
 *
 * Generate a timeout event in response to the lqm timer expiring.
 */
static void
lqm_timeout(void *arg)
{
	lqmMachine_t *machp = arg;

	machp->timedoutid = machp->lqm_send;

	ppp_cross_fsm(machp->linkp, PPPIN_TIMEOUT1, pppLQM_REPORT,
		CROSS_LO);
}


/*
 * alloc_lqm_machine()
 *
 * Allocate and lqm machine structure.
 */
lqmMachine_t *
alloc_lqm_machine(queue_t *readq, pppLink_t *linkp)
{
	lqmMachine_t	*machp;

	machp = (lqmMachine_t *)kmem_zalloc(sizeof (lqmMachine_t), KM_NOSLEEP);

	if (machp == NULL) {
		return (NULL);
	}

	machp->readq = readq;

	machp->linkp =  linkp;

	return (machp);
}


/*
 * free_lqm_machine()
 *
 * Free the lqm machine structure.
 */
void
free_lqm_machine(lqmMachine_t *machp)
{
	cancel_lqm_timer(machp);
	(void) kmem_free(machp, sizeof (lqmMachine_t));
}


/*
 * do_incoming_lqm()
 *
 * Process an incoming lqm packet.
 */
void
do_incoming_lqm(lqmMachine_t *machp, mblk_t *mp)
{
	mblk_t *zmp;
	LQM_pack_t	*lqr, templqr;

	if (!ISPULLEDUP(mp)) {
		zmp = msgpullup(mp, -1);
		freemsg(mp);
		mp = zmp;
		if (mp == NULL) {
			return;
		}
	}


	(void) adjmsg(mp, PPP_FR_HDRSZ);

	bcopy((caddr_t)mp->b_rptr, (caddr_t)&templqr, sizeof (templqr));
	machp->last_lqm_in = ntoh_LQM_pack_t(templqr);


	lqr = &machp->last_lqm_in;
	if (machp->linkp->conf.pppLinkLocalMagicNumber &&
	    lqr->magic_num == machp->linkp->conf.pppLinkLocalMagicNumber) {
		ppp_reneg(machp->linkp);
		freemsg(mp);
		return;
	}
	if (machp->send_on_rec)
		send_lqm_report(machp);
discard:
	freemsg(mp);
}


/*
 * send_lqm_report()
 *
 * Send a lqm report packet to peer.
 */
static void
send_lqm_report(lqmMachine_t *machp)
{
	mblk_t	*mp;
	LQM_pack_t	lqr, templqr;

	mp = ppp_alloc_raw_frame(pppLQM_REPORT);
	if (mp == NULL)
		return;

	lqr.magic_num = machp->linkp->conf.pppLinkLocalMagicNumber;
	lqr.lastOutLQRs = machp->last_lqm_in.peerOutLQRs;
	lqr.lastOutPackets = machp->last_lqm_in.peerOutPackets;
	lqr.lastOutOctets = machp->last_lqm_in.peerOutOctets;
	lqr.peerInLQRs = machp->lqm_info.saveInLQRs;
	lqr.peerInPackets = machp->lqm_info.saveInPackets;
	lqr.peerInDiscards = machp->lqm_info.saveInDiscards;
	lqr.peerInErrors = machp->lqm_info.saveInErrors;
	lqr.peerInOctets = machp->lqm_info.saveInOctets;

	templqr = hton_LQM_pack_t(lqr);

	bcopy((caddr_t)&templqr, (caddr_t)mp->b_wptr, sizeof (templqr));
	mp->b_wptr += sizeof (templqr);

	ppp_putnext(WR(machp->readq), mp);
}


LQM_pack_t
hton_LQM_pack_t(LQM_pack_t lqr)
{
	LQM_pack_t nlqr;

	nlqr.magic_num = htonl(lqr.magic_num);
	nlqr.lastOutLQRs = htonl(lqr.lastOutLQRs);
	nlqr.lastOutPackets = htonl(lqr.lastOutPackets);
	nlqr.lastOutOctets = htonl(lqr.lastOutOctets);
	nlqr.peerInLQRs = htonl(lqr.peerInLQRs);
	nlqr.peerInPackets = htonl(lqr.peerInPackets);
	nlqr.peerInDiscards = htonl(lqr.peerInDiscards);
	nlqr.peerInErrors = htonl(lqr.peerInErrors);
	nlqr.peerInOctets = htonl(lqr.peerInOctets);
	nlqr.peerOutLQRs = htonl(lqr.peerOutLQRs);
	nlqr.peerOutPackets = htonl(lqr.peerOutPackets);
	nlqr.peerOutOctets = htonl(lqr.peerOutOctets);
	return (nlqr);
}

LQM_pack_t
ntoh_LQM_pack_t(LQM_pack_t lqr)
{
	LQM_pack_t nlqr;

	nlqr.magic_num = ntohl(lqr.magic_num);
	nlqr.lastOutLQRs = ntohl(lqr.lastOutLQRs);
	nlqr.lastOutPackets = ntohl(lqr.lastOutPackets);
	nlqr.lastOutOctets = ntohl(lqr.lastOutOctets);
	nlqr.peerInLQRs = ntohl(lqr.peerInLQRs);
	nlqr.peerInPackets = ntohl(lqr.peerInPackets);
	nlqr.peerInDiscards = ntohl(lqr.peerInDiscards);
	nlqr.peerInErrors = ntohl(lqr.peerInErrors);
	nlqr.peerInOctets = ntohl(lqr.peerInOctets);
	nlqr.peerOutLQRs = ntohl(lqr.peerOutLQRs);
	nlqr.peerOutPackets = ntohl(lqr.peerOutPackets);
	nlqr.peerOutOctets = ntohl(lqr.peerOutOctets);
	return (nlqr);
}

/*
 * tx_lqr()
 *
 * Update the octet and packet counts for an outgoing data packet
 */
void
tx_lqr(lqmMachine_t *machp, mblk_t *mp)
{
	pppLink_t	*lp;
	LQM_pack_t	lqr, templqr;

	lp = machp->linkp;

	machp->lqm_info.outLQRs++;

	bcopy((caddr_t)((char *)mp->b_rptr + PPP_FR_HDRSZ),
	    (caddr_t)&templqr, sizeof (templqr));
	lqr = ntoh_LQM_pack_t(templqr);
	lqr.peerOutPackets = lp->mib_data.ifOutUniPackets +
		lp->mib_data.ifOutNUniPackets;
	lqr.peerOutOctets = lp->mib_data.ifOutOctets;
	lqr.peerOutLQRs = machp->lqm_info.outLQRs;
	lqr.peerInOctets = machp->lqm_info.saveInOctets;
	lqr.peerInPackets = machp->lqm_info.saveInPackets;
	lqr.peerInLQRs = machp->lqm_info.saveInLQRs;
	lqr.peerInErrors = machp->lqm_info.saveInErrors;
	lqr.peerInDiscards = machp->lqm_info.saveInDiscards;
	templqr = hton_LQM_pack_t(lqr);

	bcopy((caddr_t)&templqr,
	    (caddr_t)((char *)mp->b_rptr + PPP_FR_HDRSZ), sizeof (templqr));
}

/*
 * rx_lqr()
 *
 * Update the octet and packet counts for an incoming data packet
 */
/* ARGSUSED1 */
void
rx_lqr(lqmMachine_t *machp, mblk_t *mp)
{
	pppLink_t	*lp;

	lp = machp->linkp;

	machp->lqm_info.inLQRs++;

	machp->lqm_info.saveInLQRs = machp->lqm_info.inLQRs;
	machp->lqm_info.saveInPackets = lp->mib_data.ifInUniPackets +
		lp->mib_data.ifInNUniPackets;
	machp->lqm_info.saveInDiscards = lp->mib_data.ifInDiscards;
	machp->lqm_info.saveInErrors = lp->mib_data.ifInErrors;
	machp->lqm_info.saveInOctets = lp->mib_data.ifInOctets;
}

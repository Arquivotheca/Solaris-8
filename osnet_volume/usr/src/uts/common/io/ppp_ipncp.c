/*
 * Copyright (c) 1992-1998 by Sun Microsystems, Inc.
 * All rights reserved.
 */

#pragma ident	"@(#)ppp_ipncp.c 1.13	98/06/11 SMI"

/*
 * Implements the IP Network Control Protocol specific operations for PPP
 */


#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/stropts.h>
#include <sys/ddi.h>
#include <sys/dlpi.h>
#include <sys/debug.h>
#include <sys/time.h>
#include <sys/syslog.h>
#include <sys/strlog.h>
#include <sys/kmem.h>
#include <sys/mutex.h>
#include <sys/t_lock.h>
#include <sys/strsun.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>

#include <netinet/ip.h>
#include <netinet/tcp.h>

#ifdef ISERE_TREE
#include <ppp/vjcomp.h>
#include <ppp/ppp_ioctl.h>
#include <ppp/ppp_sys.h>
#include <ppp/ppp_pap.h>
#include <ppp/ppp_chap.h>
#include <ppp/ppp_extern.h>
#else
#include <sys/vjcomp.h>
#include <sys/ppp_ioctl.h>
#include <sys/ppp_sys.h>
#include <sys/ppp_pap.h>
#include <sys/ppp_chap.h>
#include <sys/ppp_extern.h>
#endif /* ISERE_TREE */


/*
 * data structure holding IP NCP implemented options
 */
static pppOption_t	*ipncp_imp_opts[PPP_MAX_IPNCP_OPTS+1];

static int		ipneg(pppMachine_t *, pppOption_t *);
static int		nak_ipneg(pppMachine_t *, pppOption_t *);
static int		ipaddress(pppMachine_t *, pppOption_t *);
static int		nak_ipaddress(pppMachine_t *, pppOption_t *);
static int		addresses(pppMachine_t *, pppOption_t *);
static int		nak_addresses(pppMachine_t *, pppOption_t *);
static vj_op_t		ntoh_vj_op_t(vj_op_t);
static vj_op_t		hton_vj_op_t(vj_op_t);


/*
 * ncp_external_event()
 *
 * Process external events generated by other layers or lm.
 */
void
ncp_external_event(pppLink_t *lp, uint_t exevent)
{
	uint_t	event;
	pppMachine_t	*machp;

	switch (exevent) {
	case PPPIN_UP:
		event = Up;
		break;
	case PPPIN_DOWN:
		event = Down;
		break;
	case PPPIN_OPEN:
		event = Open;
		break;
	case PPPIN_CLOSE:
		event = Close;
		break;
	case PPPIN_TIMEOUT1:
		machp = lp -> ncp;
		machp -> restart_counter--;
		if (machp -> timedoutid != machp -> restart)
			return;
		machp -> restart = 0;
		if (machp -> restart_counter > 0) {
			ppp_start_restart_timer(machp);
			event = Togt0;
		} else {
			event = Toeq0;
			if (REQ_SENT_STATE_PPP(machp -> state))
				ppp_error_ind(machp -> linkp, pppConfigFailed,
				    NULL, (uint_t)0);
		}
	}
	mutex_enter(&lp-> lplock);
	ppp_fsm(lp -> ncp, event);
	mutex_exit(&lp-> lplock);
}

void
ppp_apply_ipncp_option(pppMachine_t *machp, pppOption_t *op)
{
	vj_op_t				vjdata, tempvj;
	addr_pair_t			addr_pair;
	int				rslot;

	switch (op -> type) {

	case IPCompType:
		switch (ntohs(* (ushort_t *)op -> data)) {
		case VJCOMP:
			bcopy((caddr_t)op -> data,
			    (caddr_t)&tempvj,
			    sizeof (tempvj));
			vjdata = ntoh_vj_op_t(tempvj);
			machp-> linkp-> conf.pppIPcompRecv =
			    vjdata.proto;
			rslot = vjdata.max_slot + 1;
			vjsetinparms(&machp-> linkp->
			    vjstruct, (uint_t)rslot,
			    (uint_t)vjdata.cslot);
			break;

		case VJCOMP_OLD:
			machp-> linkp-> conf.pppIPcompRecv =
			    * (ushort_t *)op -> data;
			break;
		}
		break;

	case IPAddr:
		PPP_STRDBG("LENGTH= %d\n", op -> length);
		bcopy((caddr_t)op -> data, (caddr_t)&addr_pair,
		    sizeof (addr_pair));
		machp-> linkp-> conf.pppIPLocalAddr = addr_pair.source;
		machp-> linkp-> conf.pppIPRemoteAddr = addr_pair.dest;
		break;
	case IPAddrNew:
		PPP_STRDBG("LENGTH= %d\n", op -> length);
		bcopy((caddr_t)op -> data,
		    (caddr_t)&machp-> linkp->
		    conf.pppIPLocalAddr, sizeof (address_t));
		break;
	}
}


/*
 * nak_addresses()
 *
 * negotiate inbound IP-Addresses option
 *
 * Peer has NAKed our address suggestion.  We'll accept his alternate values
 * if:
 *	1. Both the source and address parts in the NAK are nonzero
 *	2. Our local address is currently uninitialized, or the dest
 *	   part of the NAK equals our current local address.
 *
 *	OPT_OK if the the new values are OK for this peer
 *	OPT_NOK if the new values are no good (forces backoff of option)
 */
static int
nak_addresses(pppMachine_t *machp, pppOption_t *op)
{
	addr_pair_t	addr_pair;

	if (op -> length != 10)
		return (OPT_NOK);

	bcopy((caddr_t)op -> data, (caddr_t)&addr_pair, sizeof (addr_pair));

	if ((addr_pair.source == 0) || (addr_pair.dest == 0) ||
	    (machp-> linkp-> conf.pppIPLocalAddr != 0 &&
	    addr_pair.source != machp-> linkp-> conf.pppIPLocalAddr)) {
		return (OPT_NOK);
	}
	return (OPT_OK);
}


/*
 * nak_ipaddress()
 *
 * negotiate inbound IP-address option
 *
 * Peer has NAKed our address suggestion.  We'll accept his alternate values
 * if:
 *
 *	1. The suggested value is nonzero
 *	2. The local address we currently have is zero or equal to the
 *	   peer's suggested value
 *
 *	OPT_OK if the the new value is OK for this peer
 *	OPT_NOK if the new value is no good (forces backoff of option)
 */


static int
nak_ipaddress(pppMachine_t *machp, pppOption_t *op)
{
	address_t	source;

	if (op -> length != 6)
		return (OPT_NOK);

	bcopy((caddr_t)op -> data, (caddr_t)&source, sizeof (address_t));

	if ((source == 0) || (machp-> linkp-> conf.pppIPLocalAddr != 0 &&
			source != machp-> linkp-> conf.pppIPLocalAddr)) {
		return (OPT_NOK);
	}
	return (OPT_OK);
}


/*
 * ipaddress()
 *
 * Negotiate outbound IP-Address option
 *
 * Peer has sent us an address negotiation.
 *
 * If the sent address is nonzero, set it internally as the remote address.
 * If the sent address is zero and we have a nonzero address for the peer
 *  send a NAK with the peer's address.
 * Else reject the option.
 */
static int
ipaddress(pppMachine_t *machp, pppOption_t *op)
{
	address_t	rem_addr;

	if (op -> length != 6)
		return (OPT_NOK);

	if (op -> flags & DO_NAK) {
		op -> length = 6;
		bcopy((caddr_t)&machp-> linkp-> conf.pppIPRemoteAddr,
		    (caddr_t)op -> data, sizeof (address_t));
		return (OPT_NEW);
	}

	bcopy((caddr_t)op -> data, (caddr_t)&rem_addr,
	    sizeof (rem_addr));

	if (rem_addr != 0) {
		machp-> linkp-> conf.pppIPRemoteAddr = rem_addr;
		return (OPT_OK);
	} else if (machp-> linkp-> conf.pppIPRemoteAddr != 0) {
		bcopy((caddr_t)&machp-> linkp-> conf.pppIPRemoteAddr,
		    (caddr_t)op -> data, sizeof (address_t));
		return (OPT_NEW);
	} else {
		return (OPT_NOK);
	}
}


/*
 * addresses()
 *
 * Negotiate outbound IP-Addresses option
 *
 * Peer has sent us an address negotiation.
 *
 */
static int
addresses(pppMachine_t *machp, pppOption_t *op)
{
	addr_pair_t	addr_pair;
	int	rval;

	if (op -> length != 10)
		return (OPT_NOK);

	if (op -> flags & DO_NAK) {
		op -> length = 10;
		addr_pair.source = machp-> linkp-> conf.pppIPRemoteAddr;
		addr_pair.dest = machp -> linkp-> conf.pppIPLocalAddr;

		bcopy((caddr_t)&addr_pair, (caddr_t)op-> data,
		    sizeof (addr_pair));
		return (OPT_NEW);
	}
	bcopy((caddr_t)op-> data, (caddr_t)&addr_pair,
		sizeof (addr_pair));

	if ((addr_pair.source == 0 &&
	    machp-> linkp-> conf.pppIPRemoteAddr == 0) ||
	    (addr_pair.dest != 0 && machp-> linkp-> conf.pppIPLocalAddr != 0 &&
	    addr_pair.dest != machp-> linkp-> conf.pppIPLocalAddr)) {

		return (OPT_NOK);
	}

	rval = OPT_OK;
	if (addr_pair.source == 0) {
		addr_pair.source =  machp-> linkp-> conf.pppIPRemoteAddr;
		rval = OPT_NEW;
	} else {
		machp-> linkp-> conf.pppIPRemoteAddr = addr_pair.source;
	}

	if (addr_pair.dest == 0) {
		addr_pair.dest = machp-> linkp-> conf.pppIPLocalAddr;
		rval = OPT_NEW;
	} else {
		machp-> linkp-> conf.pppIPLocalAddr = addr_pair.dest;
	}
	bcopy((caddr_t)&addr_pair, (caddr_t)op-> data,
		sizeof (addr_pair));
	return (rval);
}


/*
 * ipneg()
 *
 * Peer has sent an option requesting IP compression.
 */
static int
ipneg(pppMachine_t *machp, pppOption_t *op)
{
	ushort_t temps;
	vj_op_t			tempvj, vjdata;
	int	rslot;
	int	new_opt = 0;

	if (op -> length < 4)
		return (OPT_NOK);

	bcopy((caddr_t)op-> data, (caddr_t)&temps, sizeof (temps));

	switch (ntohs(temps)) {
		case VJCOMP_OLD:
			if (op -> length != 4)
				return (OPT_NOK);

			machp->linkp->conf.pppIPcompSend = VJCOMP;
			return (OPT_OK);
		case VJCOMP:
			if (op -> length != 6)
				return (OPT_NOK);

			bcopy((caddr_t)op-> data, (caddr_t)&tempvj,
				sizeof (tempvj));
			vjdata = ntoh_vj_op_t(tempvj);
			rslot = vjdata.max_slot + 1;
			if (rslot > MAX_STATES || rslot < MIN_STATES) {
				if (rslot > MAX_STATES)
					vjdata.max_slot = MAX_STATES - 1;
				else
					vjdata.max_slot = MIN_STATES - 1;

				new_opt = 1;
			}

			if (vjdata.cslot != 0 && vjdata.cslot != 1) {
				vjdata.cslot = 1;
				new_opt = 1;
			}

			if (new_opt) {
				tempvj = hton_vj_op_t(vjdata);
				bcopy((caddr_t)&tempvj, (caddr_t)op-> data,
					sizeof (tempvj));
				return (OPT_NEW);
			}

			vjsetoutparms(&machp->linkp->vjstruct,
			    rslot, (uint_t)vjdata.cslot);
			machp->linkp->conf.pppIPcompSend = VJCOMP;
			return (OPT_OK);

		default:
			return (OPT_NOK);
	}
}


/*
 * nak_ipneg()
 *
 * Peer has nacked our option requesting IP compression.
 */
/* ARGSUSED */
static int
nak_ipneg(pppMachine_t *machp, pppOption_t *op)
{
	ushort_t temps;
	vj_op_t			tempvj, vjdata;
	int	rslot;

	if (op -> length < 4)
		return (OPT_NOK);

	bcopy((caddr_t)op-> data, (caddr_t)&temps, sizeof (temps));

	switch (ntohs(temps)) {
		case VJCOMP_OLD:
			if (op -> length != 4)
				return (OPT_NOK);
			return (OPT_OK);
		case VJCOMP:
			if (op -> length != 6)
				return (OPT_NOK);
			bcopy((caddr_t)op-> data, (caddr_t)&tempvj,
				sizeof (tempvj));
			vjdata = ntoh_vj_op_t(tempvj);
			rslot = vjdata.max_slot + 1;
			if (rslot > MAX_STATES || rslot < MIN_STATES ||
			    (vjdata.cslot != 0 && vjdata.cslot != 1)) {
				return (OPT_NOK);
			}
			return (OPT_OK);

		default:
			return (OPT_NOK);
	}
}


/*
 * ppp_ipncp_initialize()
 *
 * Initialize the ipncp layer
 *
 * Returns 0 on success < 0 otherwise
 */
int
ppp_ipncp_initialize(void)
{
/*
 * create implemented IP NCP options list
 */
	int error;

	bzero((caddr_t)ipncp_imp_opts, sizeof (ipncp_imp_opts));

/*
 * IPCompType negotiation handler is ipneg()
 *
 * [RFC1331 page 6]
 */

	error =

	add_opt(ipncp_imp_opts, IPCompType, 0, NULL, ipneg) |

	/* Old IPAddr negotiation handler is addresses */

	add_opt(ipncp_imp_opts, IPAddr, 0, NULL, addresses) |

	/* 1332 IPAddr negotiation handler is ipaddress */

	add_opt(ipncp_imp_opts, IPAddrNew, 0, NULL, ipaddress);

	return (error);
}


/*
 * ppp_get_conf_ipncp()
 *
 * Get the ipncp configuration information.
 *
 * Returns 0
 */
int
ppp_get_conf_ipncp(pppMachine_t *machp, pppLinkControlEntry_t *conf)
{
	conf -> pppLinkAllowAddr = machp -> allowneg[IPAddr];
	conf -> pppLinkAllowHdrComp = machp -> allowneg[IPCompType];
	return (0);
}


/*
 * ppp_set_conf_ipncp()
 *
 * Set the ipncp configuration information
 *
 * Return 0 on success < 0 on error
 */
int
ppp_set_conf_ipncp(pppMachine_t *machp, pppLinkControlEntry_t *conf)
{
	vj_op_t			vjdata, tempvj;
	int rc;
	ushort_t		tempcomp;
	addr_pair_t		addr_pair;

	machp -> allowneg[IPAddr] =
	    CONV_OPT(conf -> pppLinkAllowAddr, machp, IPAddr);
	machp -> allowneg[IPAddrNew] =
	    CONV_OPT(conf -> pppLinkAllowAddr, machp, IPAddrNew);
	machp -> allowneg[IPCompType] =
	    CONV_OPT(conf -> pppLinkAllowHdrComp, machp, IPCompType);

	tempcomp = htons(VJCOMP_OLD);

	rc = add_opt(machp-> inbound,
		IPCompType, 4,
		(caddr_t)&tempcomp, nak_ipneg);
	if (rc)
		return (rc);

	vjdata.proto = VJCOMP;
	vjdata.max_slot = MAX_STATES - 1;
	vjdata.cslot = CSLOT;
	tempvj = hton_vj_op_t(vjdata);
	rc = add_opt(machp-> inbound,
		IPCompType, 6,
		(caddr_t)&tempvj, nak_ipneg);
	if (rc)
		return (rc);

	rc = add_opt(machp -> inbound, IPAddrNew, 6,
	    (caddr_t)&conf->pppIPLocalAddr, nak_ipaddress);

	if (rc)
		return (rc);

	addr_pair.source = conf->pppIPLocalAddr;
	addr_pair.dest = conf->pppIPRemoteAddr;

	rc = add_opt(machp->inbound, IPAddr, 10, (caddr_t)&addr_pair,
	    nak_addresses);
	if (rc)
		return (rc);
	return (0);
}


/*
 * alloc_ipncp_machine()
 *
 * Allocate ipncp machine
 *
 * Returns pointer to allocated machine on success, NULL on failure
 */
pppMachine_t   *
alloc_ipncp_machine(queue_t *readq, pppLink_t *linkp)
{
	pppMachine_t	*machp;
	int			i;


	PPP_MEMDBG("alloc_machine: allocating machine type %x\n",
	    pppIP_NCP);
	machp = (pppMachine_t *)kmem_zalloc(sizeof (pppMachine_t), KM_NOSLEEP);
	if (machp == NULL) {
		return (NULL);
	}

/*
 * Set initial link/network control protocol options
 */
	machp->protocol = pppIP_NCP;

	machp->ntype = pppIP_NCP & 0x0fff;

	machp->state = S0;	/* Closed */

	machp->linkp = linkp;	/* ptr to parent link */

	machp->readq = readq;

	machp->optsz = PPP_MAX_IPNCP_OPTS;
	machp->imp = ipncp_imp_opts;

	machp -> max_attempts = MAX_NEG_ATTEMPTS;
	machp -> attempts = MAX_NEG_ATTEMPTS;

	machp-> standard_allow[IPAddr] = LOC_OPTIONAL | REM_OPTIONAL;
	machp-> standard_allow[IPAddrNew] = LOC_OPTIONAL | REM_OPTIONAL;
	machp-> standard_allow[IPCompType] = LOC_OPTIONAL | REM_OPTIONAL;

	for (i = 0; i < PPP_MAX_IPNCP_OPTS; i++) {
		machp -> allowneg[i] = machp -> standard_allow[i];
	}

	return (machp);
}

static vj_op_t
ntoh_vj_op_t(vj_op_t vjs)
{
	vj_op_t newvj;

	newvj.proto = ntohs(vjs.proto);
	newvj.max_slot = vjs.max_slot;
	newvj.cslot = vjs.cslot;
	return (newvj);
}

vj_op_t
hton_vj_op_t(vj_op_t vjs)
{
	vj_op_t newvj;

	newvj.proto = htons(vjs.proto);
	newvj.max_slot = vjs.max_slot;
	newvj.cslot = vjs.cslot;
	return (newvj);
}
